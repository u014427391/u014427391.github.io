<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Nicky&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.ittrading.cn/"/>
  <updated>2018-01-16T09:56:01.945Z</updated>
  <id>http://blog.ittrading.cn/</id>
  
  <author>
    <name>Nicky</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://blog.ittrading.cn/2018/01/16/Swagger%20UI%E6%95%99%E7%A8%8B%20API%20%E6%96%87%E6%A1%A3%E7%A5%9E%E5%99%A8/"/>
    <id>http://blog.ittrading.cn/2018/01/16/Swagger UI教程 API 文档神器/</id>
    <published>2018-01-16T09:29:48.700Z</published>
    <updated>2018-01-16T09:56:01.945Z</updated>
    
    <content type="html"><![CDATA[<h2 id="title-Swagger-UI教程-API-文档神器"><a href="#title-Swagger-UI教程-API-文档神器" class="headerlink" title="title : Swagger UI教程 API 文档神器"></a>title : Swagger UI教程 API 文档神器</h2><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在一些接口项目中，API的使用很频繁，所以一款API在线文档生成和测试工具非常有必要。而Swagger UI就是这么一款很实用的在线工具<br>本博客介绍如何在公司或者自己的电脑上按照Swagger UI，注意因为公司的测试服务器是Linux系统的，所以本博客也只介绍基于Linux系统的Swagger环境搭建过程</p><p><excerpt in="" index="" |="" 首页摘要=""><br>+<a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><p>##服务器环境安装##</p><p>###NodeJS下载部署###<br>首先需要下载NodeJS，到nodejs官网<a href="http://nodejs.org/dist/v0.10.26，下载node-v0.10.26-linux-x64.tar.gz，因为这个是已经编译好的，所以我们先使用软件将文件上传到Linux服务器，可以使用WinSCP" target="_blank" rel="noopener">http://nodejs.org/dist/v0.10.26，下载node-v0.10.26-linux-x64.tar.gz，因为这个是已经编译好的，所以我们先使用软件将文件上传到Linux服务器，可以使用WinSCP</a><br>然后用Linux的cd命令进入到你nodejs压缩文件的位置<br>解压命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xvf node-v0.10.26-linux-x64.tar.gz</span><br></pre></td></tr></table></figure></p><p>然后进入文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd node-v0.10.26-linux-x64/bin</span><br></pre></td></tr></table></figure><p>执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./node</span><br></pre></td></tr></table></figure><p>设置node全局</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /root/Swagger/node-v0.10.26-linux-x64/bin/node /usr/local/bin/node</span><br></pre></td></tr></table></figure><p>设置npm全局<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /root/Swagger/node-v0.10.26-linux-x64/bin/npm /usr/local/bin/npm</span><br></pre></td></tr></table></figure></p><p>检测nodejs和npm是否安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>可以看到版本号，什么安装成功</p><p>###express下载部署####<br>安装好NodeJS和NPM之后，我们就可以安装express了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express --save</span><br></pre></td></tr></table></figure></p><p>以下几个重要的模块是需要与 express 框架一起安装的：<br>body-parser - node.js 中间件，用于处理 JSON, Raw, Text 和 URL 编码的数据。<br>cookie-parser - 这就是一个解析Cookie的工具。通过req.cookies可以取到传过来的cookie，并把它们转成对象。<br>multer - node.js 中间件，用于处理 enctype=”multipart/form-data”（设置表单的MIME编码）的表单数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install body-parser --save</span><br><span class="line">npm install cookie-parser --save</span><br><span class="line">npm install multer --save</span><br></pre></td></tr></table></figure></p><p>检测是否安装成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm list express</span><br></pre></td></tr></table></figure></p><p>###NodeJS开机启动####<br>然后设置NodeJS开机启动<br>安装forever<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install forever -g</span><br></pre></td></tr></table></figure></p><p>设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">forever start test.js</span><br><span class="line">forever stop test.js</span><br><span class="line">forever restart test.js</span><br></pre></td></tr></table></figure></p><p>##Swagger UI安装部署##<br>github上clone：<a href="https://github.com/swagger-api/swagger-ui" target="_blank" rel="noopener">https://github.com/swagger-api/swagger-ui</a><br>如果有下载Git，就是用git下载，获取访问github，直接下载</p><p>之后可以根据公司需要，在Linux上mkdir，我是先在root路径，创建一个node_app文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir node_app</span><br></pre></td></tr></table></figure></p><p>进入node_app<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd node_app</span><br></pre></td></tr></table></figure></p><p>环境配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure><p>下面的提示可以根据自己需要填写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">name: (node_app) node_app</span><br><span class="line">version: (1.0.0)</span><br><span class="line">description:</span><br><span class="line">entry point: (index.js)</span><br><span class="line">test command:</span><br><span class="line">git repository:</span><br><span class="line">keywords:</span><br><span class="line">author:</span><br><span class="line">license: (ISC)</span><br></pre></td></tr></table></figure><p>VI编辑器使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim index.js</span><br></pre></td></tr></table></figure><p>加入代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var express = require(&apos;express&apos;);</span><br><span class="line">var app = express();</span><br><span class="line"> </span><br><span class="line">app.get(&apos;/&apos;, function (req, res) &#123;</span><br><span class="line">   res.send(&apos;Hello World&apos;);</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line">var server = app.listen(3000, function () &#123;</span><br><span class="line"> </span><br><span class="line">  var host = server.address().address</span><br><span class="line">  var port = server.address().port</span><br><span class="line"> </span><br><span class="line">  console.log(&quot;应用实例，访问地址为 http://%s:%s&quot;, host, port)</span><br><span class="line"> </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>启用服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node index.js</span><br></pre></td></tr></table></figure><p>访问，输入<a href="http://公司服务器IP:3000" target="_blank" rel="noopener">http://公司服务器IP:3000</a><br>可以看到Helloworld，当然我们是要部署Swagger<br>在node_app下面创建一个public文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir public</span><br><span class="line">cd public</span><br></pre></td></tr></table></figure><p>然后将下载到的swagger ui里的dist文件夹里的文件复制到public文件夹里</p><p>修改index.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var express = require(&apos;express&apos;);</span><br><span class="line">var app = express();</span><br><span class="line"> </span><br><span class="line">app.use(&apos;/swagger&apos;,express.static(&apos;public&apos;));</span><br><span class="line"> </span><br><span class="line">app.get(&apos;/&apos;, function (req, res) &#123;</span><br><span class="line">   res.send(&apos;Hello World&apos;);</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line">var server = app.listen(3000, function () &#123;</span><br><span class="line"> </span><br><span class="line">  var host = server.address().address</span><br><span class="line">  var port = server.address().port</span><br><span class="line"> </span><br><span class="line">  console.log(&quot;swagger start&quot;, host, port)</span><br><span class="line"> </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后输入<a href="http://ip:3000/swapper，是可以看到类似page" target="_blank" rel="noopener">http://ip:3000/swapper，是可以看到类似page</a><br><img src="http://img.blog.csdn.net/20170420172247957?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDQyNzM5MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>##Swagger Editor使用##<br>Swagger Editor是Swagger UI的在线编辑器，我们可以自己搭建一个，也可以使用官方的，下面给出官方的URL:<a href="http://editor.swagger.io/#/" target="_blank" rel="noopener">http://editor.swagger.io/#/</a></p><p>github上Clone：<a href="https://github.com/swagger-api/swagger-editor" target="_blank" rel="noopener">https://github.com/swagger-api/swagger-editor</a><br>之后将swagger editor文件放在公司Linux服务器上</p><p>###Http server安装###</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g http-server</span><br></pre></td></tr></table></figure><p>启动该项目http-server swagger-editor，默认为8080端口<br>设置port并启动swagger editor<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http-server –p 2017 swagger-editor</span><br></pre></td></tr></table></figure></p><p>输入<a href="http://ip:2017/#/可以访问到自己搭建的Swagger" target="_blank" rel="noopener">http://ip:2017/#/可以访问到自己搭建的Swagger</a> Editor编辑器</p><p>参考教程<br><a href="http://www.linuxidc.com/Linux/2014-07/104489.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2014-07/104489.htm</a><br><a href="http://www.linuxidc.com/Linux/2014-06/103372.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2014-06/103372.htm</a><br><a href="http://blog.csdn.net/ron03129596/article/details/53559803" target="_blank" rel="noopener">http://blog.csdn.net/ron03129596/article/details/53559803</a><br><a href="http://www.open-open.com/lib/view/open1453452052745.html" target="_blank" rel="noopener">http://www.open-open.com/lib/view/open1453452052745.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;title-Swagger-UI教程-API-文档神器&quot;&gt;&lt;a href=&quot;#title-Swagger-UI教程-API-文档神器&quot; class=&quot;headerlink&quot; title=&quot;title : Swagger UI教程 API 文档神器&quot;&gt;&lt;/a&gt;title : Swagger UI教程 API 文档神器&lt;/h2&gt;&lt;h3 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h3&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在一些接口项目中，API的使用很频繁，所以一款API在线文档生成和测试工具非常有必要。而Swagger UI就是这么一款很实用的在线工具&lt;br&gt;本博客介绍如何在公司或者自己的电脑上按照Swagger UI，注意因为公司的测试服务器是Linux系统的，所以本博客也只介绍基于Linux系统的Swagger环境搭建过程&lt;/p&gt;
&lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;+
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.ittrading.cn/2018/01/16/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%8A%80%E6%9C%AF%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://blog.ittrading.cn/2018/01/16/中间件技术入门教程/</id>
    <published>2018-01-16T09:29:40.734Z</published>
    <updated>2018-01-16T09:55:17.084Z</updated>
    
    <content type="html"><![CDATA[<h2 id="title-中间件技术入门教程"><a href="#title-中间件技术入门教程" class="headerlink" title="title : 中间件技术入门教程"></a>title : 中间件技术入门教程</h2><p>[TOC]</p><p>##前言##<br>本博客介绍Java中间件的一些知识，仅仅是一些知识储备。</p><p>##中间件##</p><p>###中间件概念###<br>中间件：中间件是一种介于操作系统和应用软件之间的一种软件，它使用系统软件所提供的基础服务（功能），衔接网络上应用系统的各个部分或不同的应用，能够达到资源共享、功能共享的目的。<br>若是以新一代的中间件系列产品来组合应用，同时配合以可复用的商务对象构件，则应用开发费用可节省至80%。 </p><p><excerpt in="" index="" |="" 首页摘要=""><br>+<a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><p>###中间件分类###</p><ol><li>消息中间件<br>消息中间件适用与进行网络通讯的系统，建立网络通讯的通道，进行数据和文件的传送<br>产品：ActiveMQ、ZeroMQ、RabbitMQ、IBM webSphere MQ…</li><li>交易中间件<br>交易中间件管理分布与不同操作系统的数据，实现数据一致性，保证系统的负载均衡<br>产品：IBM CICS,Bea tuxedo…</li><li>对象中间件<br>保证不同厂家的软件之间的交互访问<br>产品：IBM componentbroker, iona orbix,borland visibroker…</li><li>应用服务器<br>用来构造internet/intranet应用和其它分布式构件应用<br>产品：IBM Websphere,Bea weblogic…</li><li>安全中间件<br>以公钥基础设施（pki）为核心的、建立在一系列相关国际安全标准之上的一个开放式应用开发平台<br>产品：entrust entrust…</li><li>应用集成服务器<br>把工作流和应用开发技术如消息及分布式构件结合在一起，使处理能方便自动地和构件、script 应用、工作流行为结合在一起，同时集成文档和电子邮件<br>产品：lss flowman、ibm flowmark、vitria businessagiliti</li></ol><p>##ESB##<br>ESB，即企业服务总线<br>松散耦合一直是企业软件开发中的一个很重要的内容，而面向服务的SOA编程在随着ESB的应用得到了进一步的发展，ESB就像服务提供者和服务使用者之间的中间层<br><img src="http://img.blog.csdn.net/20170424134902455?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDQyNzM5MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>##JMS##<br>JMS，即Java Message Service<br>ESB仅仅是作为一个中间层，所以应用程序之间的消息通讯必须借助JMS，即通过JMS从服务使用者接收消息，并将其转发到相应的服务提供者。<br>而且，JMS 还定义了可发送的若干不同类型的消息。例如，Text 消息包含消息的字符串表示形式；Object 消息包含序列化的 Java 对象；Map 消息包含键/值对的映射，等等。</p><p>附录：<br>MQ DEMO：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br></pre></td><td class="code"><pre><span class="line">package com.wms.batchMsg;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.sql.Timestamp;</span><br><span class="line">import java.text.ParseException;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">import org.apache.log4j.Logger;</span><br><span class="line"></span><br><span class="line">import com.ibm.mq.MQEnvironment;</span><br><span class="line">import com.ibm.mq.MQException;</span><br><span class="line">import com.ibm.mq.MQGetMessageOptions;</span><br><span class="line">import com.ibm.mq.MQMessage;</span><br><span class="line">import com.ibm.mq.MQPutMessageOptions;</span><br><span class="line">import com.ibm.mq.MQQueue;</span><br><span class="line">import com.ibm.mq.MQQueueManager;</span><br><span class="line">import com.ibm.mq.constants.MQConstants;</span><br><span class="line"></span><br><span class="line">public class MQUtil &#123;</span><br><span class="line"></span><br><span class="line">private static String qmName;      </span><br><span class="line">    private static MQQueueManager qMgr;</span><br><span class="line">    </span><br><span class="line">    private static Logger logger = Logger.getLogger(MQUtil.class);</span><br><span class="line">    </span><br><span class="line">    static&#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        MQEnvironment.hostname=ConfigManager.getValue(&quot;MQ_MQHost&quot;);</span><br><span class="line">        MQEnvironment.channel=ConfigManager.getValue(&quot;MQ_Server_Channel&quot;);</span><br><span class="line">        MQEnvironment.CCSID=Integer.parseInt(ConfigManager.getValue(&quot;MQ_CCSID&quot;));</span><br><span class="line">        MQEnvironment.port=Integer.parseInt(ConfigManager.getValue(&quot;MQ_port&quot;));</span><br><span class="line">        //MQEnvironment.userID = ConfigManager.getValue(&quot;MQ_UserId&quot;);</span><br><span class="line">        //MQEnvironment.password = ConfigManager.getValue(&quot;MQ_pass&quot;);</span><br><span class="line">        qmName = ConfigManager.getValue(&quot;MQ_QMname&quot;);</span><br><span class="line">        MQEnvironment.properties.put(MQConstants.TRANSPORT_PROPERTY,MQConstants.TRANSPORT_MQSERIES_CLIENT);</span><br><span class="line">        qMgr = new MQQueueManager(qmName);</span><br><span class="line">&#125;catch(MQException e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">logger.info(&quot;qManager failed: Completion code &quot; + e.completionCode + &quot; Reason Code is &quot;</span><br><span class="line">+ e.reasonCode);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static MQQueue getSendQueue(String queueName) &#123;</span><br><span class="line">MQQueue sQueue;</span><br><span class="line">        int openSendOptions = MQConstants.MQOO_OUTPUT | MQConstants.MQOO_FAIL_IF_QUIESCING</span><br><span class="line">                | MQConstants.MQOO_SET_IDENTITY_CONTEXT;</span><br><span class="line">        try &#123;</span><br><span class="line">            sQueue = qMgr.accessQueue(queueName, openSendOptions);</span><br><span class="line">        &#125; catch (MQException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return sQueue;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static MQQueue getReceiveQueue(String revQueueName)&#123;</span><br><span class="line">MQQueue rQueue ;</span><br><span class="line">int openRcvOptions = MQConstants.MQOO_INPUT_AS_Q_DEF | MQConstants.MQOO_FAIL_IF_QUIESCING;</span><br><span class="line">try&#123;</span><br><span class="line">rQueue = qMgr.accessQueue(revQueueName, openRcvOptions);</span><br><span class="line">&#125;catch(MQException e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">return rQueue;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    public static void sendMsg(MQMsgEntity entity,String queueName) &#123;</span><br><span class="line">MQQueue sendQ = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            MQMessage qMsg = new MQMessage();</span><br><span class="line">            byte[] qByte = entity.getMsgStr().getBytes(&quot;UTF-8&quot;);</span><br><span class="line">//            String message = entity.getMsgStr();</span><br><span class="line">            qMsg.messageId = MQConstants.MQMI_NONE;</span><br><span class="line">            //TODO send and receive</span><br><span class="line">            if(entity.getCorrelId()!=null)&#123;</span><br><span class="line">            qMsg.correlationId = entity.getCorrelId();</span><br><span class="line">            &#125;</span><br><span class="line">            qMsg.format = MQConstants.MQFMT_STRING;</span><br><span class="line">            qMsg.write(qByte);</span><br><span class="line">            MQPutMessageOptions pmo = new MQPutMessageOptions();</span><br><span class="line">            pmo.options = pmo.options + MQConstants.MQPMO_NEW_MSG_ID;</span><br><span class="line">            pmo.options = pmo.options + MQConstants.MQPMO_NO_SYNCPOINT;</span><br><span class="line">            pmo.options = pmo.options + MQConstants.MQPMO_SET_IDENTITY_CONTEXT;</span><br><span class="line">            sendQ = getSendQueue(queueName);</span><br><span class="line">            sendQ.put(qMsg, pmo);</span><br><span class="line">            qMgr.commit();</span><br><span class="line">            //logger.info(&quot;The send message is: &quot; +new String(qByte,&quot;UTF-8&quot;));</span><br><span class="line">        &#125; catch (MQException e) &#123;</span><br><span class="line">            logger.info(&quot;A WebSphere MQ error occurred : Completion code &quot;</span><br><span class="line">                            + e.completionCode + &quot; Reason Code is &quot;</span><br><span class="line">                            + e.reasonCode);</span><br><span class="line">        &#125; catch (java.io.IOException e) &#123;</span><br><span class="line">        logger.info(&quot;An error occurred whilst to the message buffer &quot;</span><br><span class="line">                            + e);</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">        if(sendQ!=null)&#123;</span><br><span class="line">        sendQ.close();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;catch(MQException e)&#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">logger.info(&quot;Error for MQ connection:&quot;+e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">//    public static void messageHandlerByQueueName(MQMsgEntity entity,String queueName) &#123;</span><br><span class="line">//    try &#123;</span><br><span class="line">//    if(queueName.equalsIgnoreCase(&quot;sap_OrdersQueue&quot;))&#123;</span><br><span class="line">//        ECOrder order = new ECOrder();</span><br><span class="line">//        order.CallOrderCURFC(entity, &quot;ZECI001&quot;);</span><br><span class="line">//        &#125;else if(queueName.equalsIgnoreCase(&quot;sap_OrderPendReqQueue&quot;))&#123;</span><br><span class="line">//        ECOrderPending orderPending = new ECOrderPending();</span><br><span class="line">//        orderPending.CallOrderPendRFC(entity, &quot;ZECI005&quot;);</span><br><span class="line">//        &#125;else if(queueName.equalsIgnoreCase(&quot;sap_OrderPendCancelQueue&quot;))&#123;</span><br><span class="line">//        ECOrderPending orderPending = new ECOrderPending();</span><br><span class="line">//        orderPending.CallCancelOrderPendRFC(entity, &quot;ZECI006&quot;);</span><br><span class="line">//        &#125;else if(queueName.equalsIgnoreCase(&quot;sap_ECReturnsQueue&quot;))&#123;</span><br><span class="line">//        ECOrder order = new ECOrder();</span><br><span class="line">//        order.callOrderCancelRFC(entity, &quot;ZECI001&quot;);</span><br><span class="line">//        &#125;else if(queueName.equalsIgnoreCase(&quot;sap_downpaymentQueue&quot;))&#123;</span><br><span class="line">//        ECDownPayment downPayment = new ECDownPayment();</span><br><span class="line">//        downPayment.callDownPaymentRFC(entity, &quot;ZECI007&quot;);</span><br><span class="line">//        &#125;else if(queueName.equalsIgnoreCase(&quot;sap_360LBPQueue&quot;))&#123;</span><br><span class="line">//        EC360LBP lbp = new EC360LBP();</span><br><span class="line">//        lbp.generateHtmlFromQueue(entity.getMsgStr());</span><br><span class="line">//        &#125;</span><br><span class="line">//&#125; catch (Exception e) &#123;</span><br><span class="line">//e.printStackTrace();</span><br><span class="line">//logger.error(e.getMessage());</span><br><span class="line">//&#125;</span><br><span class="line">//    </span><br><span class="line">//    &#125;</span><br><span class="line">    </span><br><span class="line">    public MQQueueManager generateNewMQQM()&#123;</span><br><span class="line">MQQueueManager qMgr = null;</span><br><span class="line">try&#123;</span><br><span class="line">  </span><br><span class="line">        MQEnvironment.hostname=ConfigManager.getValue(&quot;MQ_MQHost&quot;);</span><br><span class="line">        MQEnvironment.channel=ConfigManager.getValue(&quot;MQ_Server_Channel&quot;);</span><br><span class="line">        MQEnvironment.CCSID=Integer.parseInt(ConfigManager.getValue(&quot;MQ_CCSID&quot;));</span><br><span class="line">        MQEnvironment.port=Integer.parseInt(ConfigManager.getValue(&quot;MQ_port&quot;));   </span><br><span class="line">        String qmName = ConfigManager.getValue(&quot;MQ_QMname&quot;);</span><br><span class="line">        MQEnvironment.properties.put(MQConstants.TRANSPORT_PROPERTY,MQConstants.TRANSPORT_MQSERIES_CLIENT);</span><br><span class="line">        qMgr = new MQQueueManager(qmName);</span><br><span class="line">        </span><br><span class="line">&#125;catch(MQException e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">logger.info(&quot;qManager failed: Completion code &quot; + e.completionCode + &quot; Reason Code is &quot;</span><br><span class="line">+ e.reasonCode);</span><br><span class="line">&#125;</span><br><span class="line">return qMgr;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    public void MultiThreadGetMqMessage(MQQueueManager qMgr,String queueName)&#123;</span><br><span class="line">    MQQueue revQ = null;</span><br><span class="line">        String mqString = null;</span><br><span class="line">        MQMsgEntity entity = new MQMsgEntity();</span><br><span class="line">        </span><br><span class="line">        int openRcvOptions = MQConstants.MQOO_INPUT_AS_Q_DEF | MQConstants.MQOO_FAIL_IF_QUIESCING;</span><br><span class="line">        try &#123;</span><br><span class="line">        MQMessage retrievedMessage = new MQMessage();</span><br><span class="line">            MQGetMessageOptions gmo = new MQGetMessageOptions();</span><br><span class="line">            gmo.options += MQConstants.MQPMO_NO_SYNCPOINT;// </span><br><span class="line">            gmo.options = gmo.options + MQConstants.MQGMO_WAIT;//</span><br><span class="line">            gmo.options = gmo.options + MQConstants.MQGMO_FAIL_IF_QUIESCING;// </span><br><span class="line">            gmo.waitInterval = MQConstants.MQWI_UNLIMITED;// </span><br><span class="line">            gmo.matchOptions = MQConstants.MQMO_MATCH_MSG_ID;</span><br><span class="line">            retrievedMessage.format=MQConstants.MQFMT_STRING;</span><br><span class="line">            //  MQC.MQWI_UNLIMITED;</span><br><span class="line">            revQ = qMgr.accessQueue(queueName, openRcvOptions);</span><br><span class="line">            revQ.get(retrievedMessage, gmo);</span><br><span class="line">            qMgr.commit();</span><br><span class="line">            int length = retrievedMessage.getDataLength();</span><br><span class="line">            if(length &gt;0)&#123;</span><br><span class="line">            long startTime = System.currentTimeMillis();</span><br><span class="line">            byte[] msg = new byte[length];</span><br><span class="line">            retrievedMessage.readFully(msg);</span><br><span class="line">            mqString = new String(msg, &quot;UTF-8&quot;);</span><br><span class="line">            if(queueName.equalsIgnoreCase(&quot;sap_360LBPQueue&quot;))&#123;</span><br><span class="line">            mqString = mqString.replace(&quot;&apos;&quot;, &quot;\&quot;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            long timeuse = System.currentTimeMillis() - startTime;</span><br><span class="line">            Date currentDate = new Date();</span><br><span class="line">    Timestamp receiveTimestamp = new Timestamp(currentDate.getTime());</span><br><span class="line">            logger.info(&quot;=========mqString from &quot;+queueName+&quot; :&quot;+mqString);</span><br><span class="line">            DBUtil.insertIntoMQLog(&quot;Receive&quot;,queueName, mqString, timeuse, &quot;success&quot;, &quot;&quot;, null, receiveTimestamp);</span><br><span class="line">            entity.setMsgStr(mqString);</span><br><span class="line">            //messageHandlerByQueueName(entity,queueName);</span><br><span class="line">            </span><br><span class="line">    </span><br><span class="line">            &#125;else&#123;</span><br><span class="line">            logger.info(&quot;Error MQ string Sent!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (MQException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">            if (e.reasonCode != 2033) </span><br><span class="line">            &#123;</span><br><span class="line">            logger.info(e.getMessage());</span><br><span class="line">                logger.info(&quot;Completion code &quot;</span><br><span class="line">                        + e.completionCode + &quot; Reason Code is &quot; + e.reasonCode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            logger.info(&quot;IO error:&quot; + e.getMessage());</span><br><span class="line">        &#125; finally&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">        if(revQ!=null)&#123;</span><br><span class="line">        revQ.close();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;catch(MQException mqEx)&#123;</span><br><span class="line">int rc = mqEx.reasonCode;</span><br><span class="line">if (rc != MQException.MQRC_NO_MSG_AVAILABLE)</span><br><span class="line">&#123;</span><br><span class="line">logger.info(&quot; PUT Message failed with rc = &quot; </span><br><span class="line">+ rc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static String getMQMessage(String queueName) throws ParseException &#123;</span><br><span class="line">        MQQueue revQ = null;</span><br><span class="line">        String mqString = null;</span><br><span class="line">        MQMsgEntity entity = new MQMsgEntity();</span><br><span class="line">        try &#123;</span><br><span class="line">        MQMessage retrievedMessage = new MQMessage();</span><br><span class="line">            MQGetMessageOptions gmo = new MQGetMessageOptions();</span><br><span class="line">            gmo.options += MQConstants.MQPMO_NO_SYNCPOINT;// </span><br><span class="line">            gmo.options = gmo.options + MQConstants.MQGMO_WAIT;//</span><br><span class="line">            gmo.options = gmo.options + MQConstants.MQGMO_FAIL_IF_QUIESCING;// </span><br><span class="line">            gmo.waitInterval = MQConstants.MQWI_UNLIMITED;// </span><br><span class="line">            gmo.matchOptions = MQConstants.MQMO_MATCH_MSG_ID;</span><br><span class="line">            retrievedMessage.format=MQConstants.MQFMT_STRING;</span><br><span class="line">            //  MQC.MQWI_UNLIMITED;</span><br><span class="line">            revQ = getReceiveQueue(queueName);</span><br><span class="line">            revQ.get(retrievedMessage, gmo);</span><br><span class="line">            qMgr.commit();</span><br><span class="line">            int length = retrievedMessage.getDataLength();</span><br><span class="line">            if(length &gt;0)&#123;</span><br><span class="line">            byte[] msg = new byte[length];</span><br><span class="line">            retrievedMessage.readFully(msg);</span><br><span class="line">            mqString = new String(msg, &quot;UTF-8&quot;);</span><br><span class="line">            logger.info(&quot;=========getMQMessage===mqString from &quot;+queueName+&quot; :&quot;+mqString);</span><br><span class="line">            entity.setMsgStr(mqString);</span><br><span class="line">            //messageHandlerByQueueName(entity,queueName);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">            logger.info(&quot;Error MQ string Sent!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (MQException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">            if (e.reasonCode != 2033) </span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                logger.info(&quot;Completion code &quot;</span><br><span class="line">                        + e.completionCode + &quot; Reason Code is &quot; + e.reasonCode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (java.io.IOException e) &#123;</span><br><span class="line">            System.out.println(&quot;error&quot; + e.getMessage());</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">        if(revQ!=null)&#123;</span><br><span class="line">        revQ.close();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;catch(MQException mqEx)&#123;</span><br><span class="line">int rc = mqEx.reasonCode;</span><br><span class="line">if (rc != MQException.MQRC_NO_MSG_AVAILABLE)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot; PUT Message failed with rc = &quot; </span><br><span class="line">+ rc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return mqString;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public void revAndSend(MQMsgEntity entity,String queueName)&#123;</span><br><span class="line">//</span><br><span class="line">sendMsg(entity,queueName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void subscribeMessage() throws ParseException&#123;</span><br><span class="line">while(true)&#123;</span><br><span class="line">logger.info(&quot;waiting to get message.....&quot;);</span><br><span class="line">getMQMessage(&quot;sap_OrdersQueue&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void subscribeOrderPendMessage() throws ParseException&#123;</span><br><span class="line">while(true)&#123;</span><br><span class="line">logger.info(&quot;waiting to get message.....&quot;);</span><br><span class="line">getMQMessage(&quot;sap_ECReturnsQueue&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public  static void main(String[] args) throws IOException, ParseException &#123;</span><br><span class="line">MQMsgEntity entity = new MQMsgEntity();</span><br><span class="line">String sendMsg = XMLBeanUtil.readFileToString(new File(&quot;D://batchXML0108.txt&quot;));</span><br><span class="line">int intPktCtlNbr = 1;</span><br><span class="line">String StrPkt = null;</span><br><span class="line">String newPktCtlNbr =null;</span><br><span class="line">for (int i = 0; i &lt; 20000; i++) &#123;</span><br><span class="line">newPktCtlNbr = String.format(&quot;%09d&quot;, intPktCtlNbr+i);  </span><br><span class="line">StrPkt=&quot;&lt;PktCtlNbr&gt;&quot;+&quot;V&quot;+newPktCtlNbr+&quot;&lt;/PktCtlNbr&gt;&quot;;</span><br><span class="line">String changeSendMsg = sendMsg.replaceAll(&quot;&lt;PktCtlNbr&gt;6001996171&lt;/PktCtlNbr&gt;&quot;, StrPkt);</span><br><span class="line">System.out.println(StrPkt);</span><br><span class="line">entity.setMsgStr(changeSendMsg);</span><br><span class="line">sendMsg(entity,&quot;wms_SAPOrderQueue&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//MQUtil util = new MQUtil();</span><br><span class="line">//util.subscribeMessage();</span><br><span class="line">//util.subscribeOrderPendMessage();</span><br><span class="line">//util.messageHandlerByQueueName(entity, &quot;sap_360LBPQueue&quot;);</span><br><span class="line">//getMQMessage(&quot;sap_OrderPendCancelQueue&quot;);</span><br><span class="line">//System.out.println(&quot;rev message is:&quot;+message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;title-中间件技术入门教程&quot;&gt;&lt;a href=&quot;#title-中间件技术入门教程&quot; class=&quot;headerlink&quot; title=&quot;title : 中间件技术入门教程&quot;&gt;&lt;/a&gt;title : 中间件技术入门教程&lt;/h2&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;##前言##&lt;br&gt;本博客介绍Java中间件的一些知识，仅仅是一些知识储备。&lt;/p&gt;
&lt;p&gt;##中间件##&lt;/p&gt;
&lt;p&gt;###中间件概念###&lt;br&gt;中间件：中间件是一种介于操作系统和应用软件之间的一种软件，它使用系统软件所提供的基础服务（功能），衔接网络上应用系统的各个部分或不同的应用，能够达到资源共享、功能共享的目的。&lt;br&gt;若是以新一代的中间件系列产品来组合应用，同时配合以可复用的商务对象构件，则应用开发费用可节省至80%。 &lt;/p&gt;
&lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;+
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.ittrading.cn/2018/01/16/Spring%20Boot%E4%BD%BF%E7%94%A8Druid%E8%BF%9B%E8%A1%8C%E7%BB%B4%E5%BA%A6%E7%9A%84%E7%BB%9F%E8%AE%A1%E5%92%8C%E7%9B%91%E6%8E%A7/"/>
    <id>http://blog.ittrading.cn/2018/01/16/Spring Boot使用Druid进行维度的统计和监控/</id>
    <published>2018-01-16T09:29:32.172Z</published>
    <updated>2018-01-16T09:56:18.936Z</updated>
    
    <content type="html"><![CDATA[<h2 id="title-SpringBoot使用Druid进行维度的统计和监控"><a href="#title-SpringBoot使用Druid进行维度的统计和监控" class="headerlink" title="title: SpringBoot使用Druid进行维度的统计和监控"></a>title: SpringBoot使用Druid进行维度的统计和监控</h2><p>[TOC]</p><p>##Druid##<br>Druid：一款为监控而生的数据库连接池框架，整个项目由数据库连接池、插件框架和SQL解析器组成。<br>        Druid功能介于PowerDrill和Dremel之间，它几乎实现了Dremel的所有功能，并且从PowerDrill吸收一些有趣的数据格式。Druid允许以类似Dremel和PowerDrill的方式进行单表查询，同时还增加了一些新特性，如为局部嵌套数据结构提供列式存储格式、为快速过滤做索引、实时摄取和查询、高容错的分布式体系架构等。</p><p>##Spring Boot##<br>spring框架作为JavaEE框架领域的一款重要的开源框架，在企业应用开发中有着很重要的作用，同时Spring框架及其子框架很多，所以知识量很广。<br>Spring Boot：一款Spring框架的子框架，也可以叫微框架，是2014年推出的一款使Spring框架开发变得容易的框架。学过Spring框架的都知识，Spring框架难以避免地需要配置不少XMl，而使用Spring Boot框架的话，就可以使用注解开发，极大地简化基于Spring框架的开发。Spring Boot充分利用了JavaConfig的配置模式以及“约定优于配置”的理念，能够极大的简化基于Spring MVC的Web应用和REST服务开发。<br>然后本博客介绍基于IDEA编辑器的Spring Boot项目创建和部署。</p><p>##Spring Boot使用Druid监控##</p><p>###maven配置###<br>要配置spring Boot实现一个Demo的话，只要加入spring-boot-starter（核心模块）和spring-boot-starter-web（因为这个一个Web项目），可以参考我的配置，这里使用了Spring Boot热部署，需要去github上搜索jar：springloaded-1.2.4.RELEASE.jar，然后下载放在项目的lib文件夹里，可以参考我的配置</p><p><excerpt in="" index="" |="" 首页摘要=""><br>+<a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;</span><br><span class="line">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">  &lt;groupId&gt;com.example&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;demo&lt;/artifactId&gt;</span><br><span class="line">  &lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">  &lt;name&gt;demo Maven Webapp&lt;/name&gt;</span><br><span class="line"></span><br><span class="line">  &lt;properties&gt;</span><br><span class="line">    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">    &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">    &lt;druid.version&gt;1.0.24&lt;/druid.version&gt;</span><br><span class="line">    &lt;mysql.version&gt;5.1.27&lt;/mysql.version&gt;</span><br><span class="line">    &lt;spring-boot-admin.version&gt;1.4.5&lt;/spring-boot-admin.version&gt;</span><br><span class="line">  &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">  &lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.5.1.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt;</span><br><span class="line">  &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.8.1&lt;/version&gt;</span><br><span class="line">      &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">      &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;de.codecentric&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;spring-boot-admin.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;druid.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/dependencies&gt;</span><br><span class="line">  &lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">      &lt;plugin&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;/plugin&gt;</span><br><span class="line">      &lt;plugin&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-maven-plugin &lt;/artifactId&gt;</span><br><span class="line">        &lt;dependencies&gt;</span><br><span class="line">          &lt;!--springloaded hot deploy --&gt;</span><br><span class="line">          &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;springloaded&lt;/artifactId&gt;</span><br><span class="line">            &lt;systemPath&gt;$&#123;basedir&#125;/src/main/webapp/WEB-INF/lib/springloaded-1.2.5.RELEASE.jar&lt;/systemPath&gt;</span><br><span class="line">          &lt;/dependency&gt;</span><br><span class="line">        &lt;/dependencies&gt;</span><br><span class="line">        &lt;executions&gt;</span><br><span class="line">          &lt;execution&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">              &lt;goal&gt;repackage&lt;/goal&gt;</span><br><span class="line">            &lt;/goals&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">              &lt;classifier&gt;exec&lt;/classifier&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">          &lt;/execution&gt;</span><br><span class="line">        &lt;/executions&gt;</span><br><span class="line">      &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">  &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></the></p><p>###application.properties配置###</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">server.context-path=/springbootdemo</span><br><span class="line"></span><br><span class="line">#数据库访问配置</span><br><span class="line">spring.datasource.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">spring.datasource.url=jdbc:mysql://localhost:3306/myblog</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=root</span><br><span class="line"></span><br><span class="line">#数据源配置，初始化大小、最小、最大</span><br><span class="line">spring.datasource.initialSize=5</span><br><span class="line">spring.datasource.minIdle=5</span><br><span class="line">spring.datasource.maxActive=20</span><br><span class="line">#连接等待超时时间</span><br><span class="line">spring.datasource.maxWait=60000</span><br><span class="line">#配置隔多久进行一次检测(检测可以关闭的空闲连接)</span><br><span class="line">spring.datasource.timeBetweenEvictionRunsMillis=60000</span><br><span class="line">#配置连接在池中的最小生存时间</span><br><span class="line">spring.datasource.minEvictableIdleTimeMillis=300000</span><br><span class="line">spring.datasource.validationQuery=SELECT 1 FROM DUAL</span><br><span class="line">spring.datasource.testWhileIdle=true</span><br><span class="line">spring.datasource.testOnBorrow=false</span><br><span class="line">spring.datasource.testOnReturn=false</span><br><span class="line"># 打开PSCache，并且指定每个连接上PSCache的大小</span><br><span class="line">spring.datasource.poolPreparedStatements=true</span><br><span class="line">spring.datasource.maxPoolPreparedStatementPerConnectionSize=20</span><br><span class="line"># 配置监控统计拦截的filters，去掉后监控界面sql无法统计，&apos;wall&apos;用于防火墙</span><br><span class="line">spring.datasource.filters=stat,wall,log4j</span><br><span class="line"># 通过connectProperties属性来打开mergeSql功能；慢SQL记录</span><br><span class="line">spring.datasource.connectionProperties=druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000</span><br></pre></td></tr></table></figure><p>###方式一原生的servlet和filter方式###<br>编写Servlet类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.example.web.servlet;</span><br><span class="line"></span><br><span class="line">import com.alibaba.druid.support.http.StatViewServlet;</span><br><span class="line"></span><br><span class="line">import javax.servlet.annotation.WebInitParam;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by Administrator on 2017/4/28.</span><br><span class="line"> */</span><br><span class="line">@WebServlet(urlPatterns = &quot;/druid/*&quot;,</span><br><span class="line">        initParams = &#123;</span><br><span class="line">                @WebInitParam(name = &quot;allow&quot;, value = &quot;192.168.10.25,127.0.0.1&quot;),// IP白名单 (没有配置或者为空，则允许所有访问)</span><br><span class="line">                @WebInitParam(name = &quot;deny&quot;, value = &quot;192.168.1.73&quot;),// IP黑名单 (存在共同时，deny优先于allow)</span><br><span class="line">                @WebInitParam(name = &quot;loginUsername&quot;, value = &quot;admin&quot;),// 用户名</span><br><span class="line">                @WebInitParam(name = &quot;loginPassword&quot;, value = &quot;123&quot;),// 密码</span><br><span class="line">                @WebInitParam(name = &quot;resetEnable&quot;, value = &quot;false&quot;)// 禁用HTML页面上的“Reset All”功能)</span><br><span class="line">        &#125;</span><br><span class="line">)</span><br><span class="line">public class DruidStatViewServlet extends StatViewServlet&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Filter类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.example.web.filter;</span><br><span class="line"></span><br><span class="line">import com.alibaba.druid.support.http.WebStatFilter;</span><br><span class="line"></span><br><span class="line">import javax.servlet.annotation.WebFilter;</span><br><span class="line">import javax.servlet.annotation.WebInitParam;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by Administrator on 2017/4/28.</span><br><span class="line"> */</span><br><span class="line">@WebFilter(filterName=&quot;druidWebStatFilter&quot;,urlPatterns=&quot;/*&quot;,</span><br><span class="line">        initParams=&#123;</span><br><span class="line">                @WebInitParam(name=&quot;exclusions&quot;,value=&quot;*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*&quot;)// 忽略资源</span><br><span class="line">        &#125;</span><br><span class="line">)</span><br><span class="line">public class DruidWebStatFilter extends WebStatFilter&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，需要在Spring Boot启动类里设置Servlet自动扫描，不然会出现404页面找不到错误，使用@ServletComponentScan注解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package com;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.boot.builder.SpringApplicationBuilder;</span><br><span class="line">import org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;</span><br><span class="line">import org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;</span><br><span class="line">import org.springframework.boot.web.servlet.ServletComponentScan;</span><br><span class="line">import org.springframework.boot.web.support.SpringBootServletInitializer;</span><br><span class="line">import org.springframework.scheduling.annotation.EnableAsync;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">@ServletComponentScan</span><br><span class="line">@EnableAsync</span><br><span class="line">public class Application implements EmbeddedServletContainerCustomizer &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(Application.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void customize(ConfigurableEmbeddedServletContainer configurableEmbeddedServletContainer) &#123;</span><br><span class="line">configurableEmbeddedServletContainer.setPort(8087);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###方式二使用代码注册Servlet和Filter###</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">package com.example.config;</span><br><span class="line"></span><br><span class="line">import com.alibaba.druid.support.http.StatViewServlet;</span><br><span class="line">import com.alibaba.druid.support.http.WebStatFilter;</span><br><span class="line">import org.springframework.boot.web.servlet.FilterRegistrationBean;</span><br><span class="line">import org.springframework.boot.web.servlet.ServletRegistrationBean;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by Administrator on 2017/4/28.</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">public class DruidConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 注册ServletRegistrationBean</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public ServletRegistrationBean registrationBean() &#123;</span><br><span class="line">        ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), &quot;/druid1/*&quot;);</span><br><span class="line">        /** 初始化参数配置，initParams**/</span><br><span class="line">        //白名单</span><br><span class="line">        bean.addInitParameter(&quot;allow&quot;, &quot;127.0.0.1&quot;);</span><br><span class="line">        //IP黑名单 (存在共同时，deny优先于allow) : 如果满足deny的话提示:Sorry, you are not permitted to view this page.</span><br><span class="line">        bean.addInitParameter(&quot;deny&quot;, &quot;192.168.1.73&quot;);</span><br><span class="line">        //登录查看信息的账号密码.</span><br><span class="line">        bean.addInitParameter(&quot;loginUsername&quot;, &quot;admin2&quot;);</span><br><span class="line">        bean.addInitParameter(&quot;loginPassword&quot;, &quot;123&quot;);</span><br><span class="line">        //是否能够重置数据.</span><br><span class="line">        bean.addInitParameter(&quot;resetEnable&quot;, &quot;false&quot;);</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 注册FilterRegistrationBean</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public FilterRegistrationBean druidStatFilter() &#123;</span><br><span class="line">        FilterRegistrationBean bean = new FilterRegistrationBean(new WebStatFilter());</span><br><span class="line">        //添加过滤规则.</span><br><span class="line">        bean.addUrlPatterns(&quot;/*&quot;);</span><br><span class="line">        //添加不需要忽略的格式信息.</span><br><span class="line">        bean.addInitParameter(&quot;exclusions&quot;,&quot;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid2/*&quot;);</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###项目监控###<br>然后输入url访问，我的项目访问路径：<a href="http://localhost:8087/springbootdemo/druid/login.html，这个需要自己修改，我的Context配置为springbootdemo，端口配置为8087，这些可以参考我上一篇博客" target="_blank" rel="noopener">http://localhost:8087/springbootdemo/druid/login.html，这个需要自己修改，我的Context配置为springbootdemo，端口配置为8087，这些可以参考我上一篇博客</a><br><img src="http://img.blog.csdn.net/20170428110806925?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDQyNzM5MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>通过平台进行监控<br><img src="http://img.blog.csdn.net/20170428110824226?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDQyNzM5MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;title-SpringBoot使用Druid进行维度的统计和监控&quot;&gt;&lt;a href=&quot;#title-SpringBoot使用Druid进行维度的统计和监控&quot; class=&quot;headerlink&quot; title=&quot;title: SpringBoot使用Druid进行维度的统计和监控&quot;&gt;&lt;/a&gt;title: SpringBoot使用Druid进行维度的统计和监控&lt;/h2&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;##Druid##&lt;br&gt;Druid：一款为监控而生的数据库连接池框架，整个项目由数据库连接池、插件框架和SQL解析器组成。&lt;br&gt;        Druid功能介于PowerDrill和Dremel之间，它几乎实现了Dremel的所有功能，并且从PowerDrill吸收一些有趣的数据格式。Druid允许以类似Dremel和PowerDrill的方式进行单表查询，同时还增加了一些新特性，如为局部嵌套数据结构提供列式存储格式、为快速过滤做索引、实时摄取和查询、高容错的分布式体系架构等。&lt;/p&gt;
&lt;p&gt;##Spring Boot##&lt;br&gt;spring框架作为JavaEE框架领域的一款重要的开源框架，在企业应用开发中有着很重要的作用，同时Spring框架及其子框架很多，所以知识量很广。&lt;br&gt;Spring Boot：一款Spring框架的子框架，也可以叫微框架，是2014年推出的一款使Spring框架开发变得容易的框架。学过Spring框架的都知识，Spring框架难以避免地需要配置不少XMl，而使用Spring Boot框架的话，就可以使用注解开发，极大地简化基于Spring框架的开发。Spring Boot充分利用了JavaConfig的配置模式以及“约定优于配置”的理念，能够极大的简化基于Spring MVC的Web应用和REST服务开发。&lt;br&gt;然后本博客介绍基于IDEA编辑器的Spring Boot项目创建和部署。&lt;/p&gt;
&lt;p&gt;##Spring Boot使用Druid监控##&lt;/p&gt;
&lt;p&gt;###maven配置###&lt;br&gt;要配置spring Boot实现一个Demo的话，只要加入spring-boot-starter（核心模块）和spring-boot-starter-web（因为这个一个Web项目），可以参考我的配置，这里使用了Spring Boot热部署，需要去github上搜索jar：springloaded-1.2.4.RELEASE.jar，然后下载放在项目的lib文件夹里，可以参考我的配置&lt;/p&gt;
&lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;+
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.ittrading.cn/2018/01/16/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93MongoDB%E6%95%99%E7%A8%8B%E6%95%B4%E7%90%86/"/>
    <id>http://blog.ittrading.cn/2018/01/16/分布式文件存储的数据库MongoDB教程整理/</id>
    <published>2018-01-16T09:29:16.180Z</published>
    <updated>2018-01-16T09:55:55.785Z</updated>
    
    <content type="html"><![CDATA[<h2 id="title-分布式文件存储的数据库MongoDB教程整理"><a href="#title-分布式文件存储的数据库MongoDB教程整理" class="headerlink" title="title : 分布式文件存储的数据库MongoDB教程整理"></a>title : 分布式文件存储的数据库MongoDB教程整理</h2><p>[TOC]</p><h2 id="第一章MongoDB简介"><a href="#第一章MongoDB简介" class="headerlink" title="第一章MongoDB简介"></a>第一章MongoDB简介</h2><p>MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。<br>MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。<br>MongoDB 官网地址：<a href="https://www.mongodb.com/" target="_blank" rel="noopener">https://www.mongodb.com/</a><br>MongoDB 官方英文文档：<a href="https://docs.mongodb.com/manual/" target="_blank" rel="noopener">https://docs.mongodb.com/manual/</a><br>MongoDB 各平台下载地址：<a href="https://www.mongodb.com/download-center#community" target="_blank" rel="noopener">https://www.mongodb.com/download-center#community</a></p><p><excerpt in="" index="" |="" 首页摘要=""><br>+<a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><h2 id="第二章MongoDB安装"><a href="#第二章MongoDB安装" class="headerlink" title="第二章MongoDB安装"></a>第二章MongoDB安装</h2><p>###2.1 关闭SELINUX<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/selinux/config</span><br></pre></td></tr></table></figure></p><p>对配置文件进行修改，然后按ESC键，:wq保存退出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#SELINUX=enforcing </span><br><span class="line"></span><br><span class="line">#SELINUXTYPE=targeted</span><br><span class="line"></span><br><span class="line">SELINUX=disabled #增加</span><br></pre></td></tr></table></figure></p><p>:wq! #保存退出</p><p>###2.2 配置防火墙</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sysconfig/iptables</span><br></pre></td></tr></table></figure><p>可以看到配置文件，然后按I键，insert如下数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 9092 -j ACCEPT</span><br></pre></td></tr></table></figure></p><p>然后按ESC键，:wq保存退出，配置文件代码如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># Firewall configuration written by system-config-firewall</span><br><span class="line"></span><br><span class="line"># Manual customization of this file is not recommended.</span><br><span class="line"></span><br><span class="line">*filter</span><br><span class="line"></span><br><span class="line">:INPUT ACCEPT [0:0]</span><br><span class="line"></span><br><span class="line">:FORWARD ACCEPT [0:0]</span><br><span class="line"></span><br><span class="line">:OUTPUT ACCEPT [0:0]</span><br><span class="line"></span><br><span class="line">-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br><span class="line"></span><br><span class="line">-A INPUT -p icmp -j ACCEPT</span><br><span class="line"></span><br><span class="line">-A INPUT -i lo -j ACCEPT</span><br><span class="line"></span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT</span><br><span class="line"></span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 9092 -j ACCEPT</span><br><span class="line"></span><br><span class="line">-A INPUT -j REJECT --reject-with icmp-host-prohibited</span><br><span class="line"></span><br><span class="line">-A FORWARD -j REJECT --reject-with icmp-host-prohibited</span><br><span class="line"></span><br><span class="line">COMMIT</span><br></pre></td></tr></table></figure></p><p>:wq保存退出</p><p>###2.3 下载安装Mongodb<br>cd进入/usr/local/src<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src</span><br></pre></td></tr></table></figure></p><p>wget下载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-2.6.0.tgz</span><br></pre></td></tr></table></figure></p><p>tar解压<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf mongodb-linux-x86_64-2.6.0.tgz</span><br></pre></td></tr></table></figure></p><p>将解压文件移动到安装目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv mongodb-linux-x86_64-2.6.0  /usr/local/mongodb</span><br></pre></td></tr></table></figure></p><p>创建mongodb存放路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir  -p  /usr/local/mongodb/data/</span><br></pre></td></tr></table></figure></p><p>创建mongodb日志文件存放文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/local/mongodb/logs/mongodb.log</span><br></pre></td></tr></table></figure></p><p>###2.4 启动mongodb<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/mongodb/bin/mongod --port 27017 --fork --dbpath=/usr/local/mongodb/data/ --logpath=/usr/local/mongodb/logs/mongodb.log --logappend&amp;</span><br></pre></td></tr></table></figure></p><p>检查</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -lanp | grep &quot;27017&quot;</span><br></pre></td></tr></table></figure><p>进入mongodb数据库控制台<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mongo</span><br></pre></td></tr></table></figure></p><p>设置mongodb全局</p><p>添加环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile</span><br></pre></td></tr></table></figure><p>同样使用VI编辑器，加入如下配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/usr/local/mongodb/bin</span><br></pre></td></tr></table></figure></p><p>按ESC，然后:wq保存退出</p><p>使配置文件立即生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p>然后就可以全局使用mongodb命令了<br>进入mongodb控制台<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mongo  #进入MongoDB控制台</span><br><span class="line"></span><br><span class="line">show dbs #查看默认数据库</span><br><span class="line"></span><br><span class="line">use admin  #切换到admin数据库</span><br><span class="line"></span><br><span class="line">exit #退出MongoDB控制台</span><br></pre></td></tr></table></figure></p><h2 id="第三章MongoDB基本操作"><a href="#第三章MongoDB基本操作" class="headerlink" title="第三章MongoDB基本操作"></a>第三章MongoDB基本操作</h2><p>###3.1MongoDB连接<br>MongoDB连接，使用“username:password@hostname/dbname’”的形式进行连接。<br>连接本地数据库服务器，端口是默认的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongodb://localhost</span><br></pre></td></tr></table></figure></p><p>###3.2创建数据库<br>MongoDB创建数据库语法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use DATABASE_NAME</span><br></pre></td></tr></table></figure></p><p>demo：创建test数据库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use test</span><br></pre></td></tr></table></figure></p><p>如果没有数据库，就创建数据库，否就连接到指定数据库<br>查看所有的数据库，使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show dbs</span><br></pre></td></tr></table></figure></p><p>不过这时我们使用show dbs的话，还是看不到我们创建的数据库，其实是需要我们向数据库里添加数据才可以看得到的<br>demo：向test数据库里插入一行数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.test.insert(&#123;&quot;name&quot;:&quot;test&quot;&#125;)</span><br></pre></td></tr></table></figure></p><p>###3.3创建数据库<br>MongoDB删除数据库语法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.dropDatabase()</span><br></pre></td></tr></table></figure></p><p>不过一般要先使用use连接数据库，然后再删除指导数据库<br>demo：删除test数据库<br>连接test数据库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use test</span><br></pre></td></tr></table></figure></p><p>删除test数据库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.dropDatabase()</span><br></pre></td></tr></table></figure></p><p><strong>删除集合</strong><br>demo：删除test数据库的coll集合<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; use test</span><br><span class="line">switched to db runoob</span><br><span class="line">&gt; show tables</span><br><span class="line">coll</span><br><span class="line">&gt; db.coll.drop()</span><br><span class="line">true</span><br><span class="line">&gt; show tables</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p><p>###3.4插入文档<br>MongoDB插入文档语法大致如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.insert(document)</span><br></pre></td></tr></table></figure></p><p>demo：向test数据库的col集合中插入文档<br><strong>方法一</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;use test</span><br><span class="line">&gt;db.col.insert(&#123;title: &apos;MongoDB&apos;, </span><br><span class="line">    description: &apos;MongoDB NOSQL&apos;,</span><br><span class="line">    by: &apos;test&apos;,</span><br><span class="line">    url: &apos;https:&apos;,</span><br><span class="line">    tags: [&apos;mongodb&apos;, &apos;database&apos;, &apos;NoSQL&apos;],</span><br><span class="line">    likes: 100</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>查看已经写入数据的col集合<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.col.find()</span><br></pre></td></tr></table></figure></p><p><strong>方法二</strong><br>定义一个document对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">document=(&#123;title: &apos;MongoDB&apos;, </span><br><span class="line">     description: &apos;MongoDB NOSQL&apos;,</span><br><span class="line">    by: &apos;test&apos;,</span><br><span class="line">    url: &apos;https:&apos;,</span><br><span class="line">    tags: [&apos;mongodb&apos;, &apos;database&apos;, &apos;NoSQL&apos;],</span><br><span class="line">    likes: 100</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>执行，将定义好的document对象写入数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.col.insert(document)</span><br></pre></td></tr></table></figure></p><p>###3.5更新文档<br>更新文档操作语法大概如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.collection.update(</span><br><span class="line">   &lt;query&gt;,</span><br><span class="line">   &lt;update&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     upsert: &lt;boolean&gt;,</span><br><span class="line">     multi: &lt;boolean&gt;,</span><br><span class="line">     writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>参数意义：</p><ul><li>query : update的查询条件，类似sql update查询内where后面的。 </li><li>update :  update的对象和一些更新的操作符（如$,$inc…）等，也可以理解为sql update查询内set后面的 </li><li>upsert :   可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。 </li><li>multi :  可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。      </li><li>writeConcern :可选，抛出异常的级别。</li></ul><p>demo:更新test数据库的文档<br>使用test数据库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use test</span><br></pre></td></tr></table></figure></p><p>更新文档操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.col.update(&#123;&apos;title&apos;:&apos;MongoDB&apos;&#125;,&#123;$set:&#123;&apos;title&apos;:&apos;MongoDB test&apos;&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>然后查看文档是否更新<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.col.find()</span><br></pre></td></tr></table></figure></p><p><strong>修改多条相同的文档</strong><br>上诉情况是修改一条文档的，若修改多条相同的文档，则需要设置 multi 参数为 true。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.col.update(&#123;&apos;title&apos;:&apos;MongoDB&apos;&#125;,&#123;$set:&#123;&apos;title&apos;:&apos;MongoDB test&apos;&#125;&#125;,&#123;multi:true&#125;)</span><br></pre></td></tr></table></figure></p><p><strong>save()方法</strong><br>语法大概如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.collection.save(</span><br><span class="line">   &lt;document&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>参数意义</p><ol><li>document : 文档数据。</li><li>writeConcern :可选，抛出异常的级别。<br>demo：替换了 _id 为 56064f89ade2f21f36b03136 的文档数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.col.save(&#123;</span><br><span class="line">&quot;_id&quot; : ObjectId(&quot;56064f89ade2f21f36b03136&quot;),</span><br><span class="line">    &quot;title&quot; : &quot;MongoDB&quot;,</span><br><span class="line">    &quot;description&quot;: &apos;MongoDB NOSQL&apos;,</span><br><span class="line">    &quot;by&quot;: &apos;test&apos;,</span><br><span class="line">    &quot;url&quot;: &apos;https:&apos;,</span><br><span class="line">    &quot;tags&quot;: [&apos;mongodb&apos;, &apos;database&apos;, &apos;NoSQL&apos;],</span><br><span class="line">    &quot;likes&quot;: 100</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">只更新第一条记录：</span><br><span class="line">db.col.update( &#123; &quot;count&quot; : &#123; $gt : 1 &#125; &#125; , &#123; $set : &#123; &quot;test2&quot; : &quot;OK&quot;&#125; &#125; );</span><br><span class="line">全部更新：</span><br><span class="line">db.col.update( &#123; &quot;count&quot; : &#123; $gt : 3 &#125; &#125; , &#123; $set : &#123; &quot;test2&quot; : &quot;OK&quot;&#125; &#125;,false,true );</span><br><span class="line">只添加第一条：</span><br><span class="line">db.col.update( &#123; &quot;count&quot; : &#123; $gt : 4 &#125; &#125; , &#123; $set : &#123; &quot;test5&quot; : &quot;OK&quot;&#125; &#125;,true,false );</span><br><span class="line">全部添加加进去:</span><br><span class="line">db.col.update( &#123; &quot;count&quot; : &#123; $gt : 5 &#125; &#125; , &#123; $set : &#123; &quot;test5&quot; : &quot;OK&quot;&#125; &#125;,true,true );</span><br><span class="line">全部更新：</span><br><span class="line">db.col.update( &#123; &quot;count&quot; : &#123; $gt : 15 &#125; &#125; , &#123; $inc : &#123; &quot;count&quot; : 1&#125; &#125;,false,true );</span><br><span class="line">只更新第一条记录：</span><br><span class="line">db.col.update( &#123; &quot;count&quot; : &#123; $gt : 10 &#125; &#125; , &#123; $inc : &#123; &quot;count&quot; : 1&#125; &#125;,false,false );</span><br></pre></td></tr></table></figure><p>###3.6删除文档<br>MongoDB删除文档操作为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.collection.remove(</span><br><span class="line">   &lt;query&gt;,</span><br><span class="line">   &lt;justOne&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>MongoDB2.6以后版本的操作为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.collection.remove(</span><br><span class="line">   &lt;query&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     justOne: &lt;boolean&gt;,</span><br><span class="line">     writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>query :（可选）删除的文档的条件。</li><li>justOne : （可选）如果设为 true 或 1，则只删除一个文档。</li><li>writeConcern :（可选）抛出异常的级别。</li></ul><p>demo:删除title为MongoDB的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.col.remove(&#123;&apos;title&apos;:&apos;MongoDB&apos;&#125;)</span><br></pre></td></tr></table></figure></p><p>删除集合所有数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.col.remove(&#123;&#125;)</span><br></pre></td></tr></table></figure><p>###3.7MongoDB查询<br>MongoDB查询语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.find(query, projection)</span><br></pre></td></tr></table></figure><ul><li>query ：可选，使用查询操作符指定查询条件</li><li>projection ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）。<br>易读方式查询<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.col.find().pretty()</span><br></pre></td></tr></table></figure></li></ul><p><strong>除了 find() 方法之外，还有一个 findOne() 方法，它只返回一个文档。</strong></p><p>###3.8MongoDB条件操作<br><strong>MongoDB AND条件</strong>，可以传入多个键(key)，每个键(key)以逗号隔开<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.col.find(&#123;key1:value1, key2:value2&#125;).pretty()</span><br></pre></td></tr></table></figure></p><p><strong>MongoDB OR条件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.col.find(</span><br><span class="line">   &#123;</span><br><span class="line">      $or: [</span><br><span class="line">     &#123;key1: value1&#125;, &#123;key2:value2&#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">).pretty()</span><br></pre></td></tr></table></figure><p><strong>MongoDB AND和OR联合查询</strong><br> AND 和 OR 联合使用，类似常规 SQL 语句为： ‘where likes&gt;50 AND (by = ‘教程’ OR title = ‘MongoDB 教程’)’</p><p><strong>MongoDB条件操作符</strong></p><ul><li>(&gt;) 大于 ： $gt</li><li>(&lt;) 小于 ： $lt</li><li>(&gt;=) 大于等于 ： $gte</li><li>(&lt;= ) 小于等于 ： $lte<br>Demo：<br>获取 “col” 集合中 “likes” 大于 100 的数据，可以使用以下命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.col.find(&#123;&quot;likes&quot; : &#123;$gt : 100&#125;&#125;)</span><br></pre></td></tr></table></figure></li></ul><p>获取”col”集合中 “likes” 大于等于 100 的数据，可以使用以下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.col.find(&#123;likes : &#123;$gte : 100&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>获取”col”集合中 “likes” 小于 150 的数据，可以使用以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.col.find(&#123;likes : &#123;$lt : 150&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>获取”col”集合中 “likes” 小于等于 150 的数据，可以使用以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.col.find(&#123;likes : &#123;$lte : 150&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>获取”col”集合中 “likes” 大于100，小于 200 的数据，可以使用以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.col.find(&#123;likes : &#123;$lt :200, $gt : 100&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p><strong>MongoDB Limit和Skip操作符</strong><br>Limit操作符,Number表示读取的记录数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.find().limit(NUMBER)</span><br></pre></td></tr></table></figure></p><p><strong>MongoDB skip()方法</strong><br>Number表示要跳过的记录数，默认从0开始<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER)</span><br></pre></td></tr></table></figure></p><p>###3.9MongoDB $type操作符<br>MongoDB $type操作符表<br>| 类型        | 数字           | 备注  |<br>| ————- |:————-:| —–:|<br>| Double        | 1             |       |<br>| Object        | 2             |       |<br>| Array         | 4             |       |<br>| Binary data   | 5             |       |<br>| Undefined     | 6             | 已废弃 |<br>| Object id     | 7             |       |<br>| Boolean       | 8             |       |<br>| Date          | 9             |       |<br>| Null          | 10            |       |<br>|Regular Expression | 11        |       |<br>| JavaScript    | 13            |       |<br>| Symbol        | 14            |       |<br>| JavaScript (with scope) | 15  |       |<br>| 32-bit integer| 16            |       |<br>| Timestamp     | 17            |       |<br>| 64-bit integer| 18            |       |<br>| Min key       | 255           | Query with -1      |<br>| Max key       | 127           |       |</p><p>获取 “col” 集合中 title 为 String 的数据，可以使用以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.col.find(&#123;&quot;title&quot; : &#123;$type : 2&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>###3.10MongoDB排序<br>使用sort()方法对数据进行排序，sort()方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而-1是用于降序排列。<br>这是对集合进行排序的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.find().sort(&#123;KEY:1&#125;)</span><br></pre></td></tr></table></figure></p><p>###3.11MongoDB索引</p><p>索引是特殊的数据结构，索引存储在一个易于遍历读取的数据集合中，索引是对数据库表中一列或多列的值进行排序的一种结构。建立索引可以提高查询速度。如果没有索引，MongoDB在读取数据时必须扫描集合中的每个文件并选取那些符合查询条件的记录。<br>demo：查询col集合，“title”为索引字段，1为指定按升序创建索引，如果你想按降序来创建索引指定为-1即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.col.ensureIndex(&#123;&quot;title&quot;:1&#125;)</span><br></pre></td></tr></table></figure></p><p><strong>在后台创建索引</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.values.ensureIndex(&#123;open: 1, close: 1&#125;, &#123;background: true&#125;)</span><br></pre></td></tr></table></figure><p>###3.12MongoDB聚合<br>MongoDB中聚合(aggregate)主要用于处理数据(诸如统计平均值,求和等)，并返回计算后的数据结果。有点类似sql语句中的 count(*)。<br>基本语法如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION)</span><br></pre></td></tr></table></figure><p>demo：通过集合计算每个作者所写的文章数，使用aggregate()计算结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, num_tutorial : &#123;$sum : 1&#125;&#125;&#125;])</span><br></pre></td></tr></table></figure><p>以上实例类似sql语句：<br> <code>select by_user, count(*) from mycol group by by_user</code></p><p>###附录<br>Mongodb Java demo<br>附录demo：<br>去<a href="http://mongodb.github.io/mongo-java-driver/下载相应的jar，放在libs文件夹里" target="_blank" rel="noopener">http://mongodb.github.io/mongo-java-driver/下载相应的jar，放在libs文件夹里</a></p><p>pom配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- bson start --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.bson&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;bson&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.4.2&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;system&lt;/scope&gt;</span><br><span class="line">            &lt;systemPath&gt;$&#123;basedir&#125;/src/main/webapp/WEB-INF/lib/bson-3.4.2.jar&lt;/systemPath&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- bson end--&gt;</span><br><span class="line">        &lt;!-- mongodb driver start --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mongodb&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mongodb-driver&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.4.2&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;system&lt;/scope&gt;</span><br><span class="line">            &lt;systemPath&gt;$&#123;basedir&#125;/src/main/webapp/WEB-INF/lib/mongodb-driver-3.4.2.jar&lt;/systemPath&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- mongodb driver end --&gt;</span><br><span class="line">        &lt;!-- mongodb driver core start --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mongodb&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mongodb-driver-core&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.4.2&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;system&lt;/scope&gt;</span><br><span class="line">            &lt;systemPath&gt;$&#123;basedir&#125;/src/main/webapp/WEB-INF/lib/mongodb-driver-core-3.4.2.jar&lt;/systemPath&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- mongodb driver core end --&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import com.mongodb.MongoClient;</span><br><span class="line">import com.mongodb.client.MongoDatabase;</span><br><span class="line"></span><br><span class="line">public class MongoDBJDBC&#123;</span><br><span class="line">   public static void main( String args[] )&#123;</span><br><span class="line">      try&#123;   </span><br><span class="line">      // 连接到 mongodb 服务</span><br><span class="line">      MongoClient mongoClient = new MongoClient( &quot;10.10.1.1&quot; , 27017 );</span><br><span class="line"></span><br><span class="line">      // 连接到数据库</span><br><span class="line">      MongoDatabase mongoDatabase = mongoClient.getDatabase(&quot;test&quot;);</span><br><span class="line">      System.out.println(&quot;Connect to database successfully&quot;);</span><br><span class="line">      mongoDatabase.createCollection(&quot;colll&quot;);</span><br><span class="line">      System.out.println(&quot;集合创建成功&quot;);</span><br><span class="line">        </span><br><span class="line">      &#125;catch(Exception e)&#123;</span><br><span class="line">        System.err.println( e.getClass().getName() + &quot;: &quot; + e.getMessage() );</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;title-分布式文件存储的数据库MongoDB教程整理&quot;&gt;&lt;a href=&quot;#title-分布式文件存储的数据库MongoDB教程整理&quot; class=&quot;headerlink&quot; title=&quot;title : 分布式文件存储的数据库MongoDB教程整理&quot;&gt;&lt;/a&gt;title : 分布式文件存储的数据库MongoDB教程整理&lt;/h2&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;第一章MongoDB简介&quot;&gt;&lt;a href=&quot;#第一章MongoDB简介&quot; class=&quot;headerlink&quot; title=&quot;第一章MongoDB简介&quot;&gt;&lt;/a&gt;第一章MongoDB简介&lt;/h2&gt;&lt;p&gt;MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。&lt;br&gt;MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。&lt;br&gt;MongoDB 官网地址：&lt;a href=&quot;https://www.mongodb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.mongodb.com/&lt;/a&gt;&lt;br&gt;MongoDB 官方英文文档：&lt;a href=&quot;https://docs.mongodb.com/manual/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.mongodb.com/manual/&lt;/a&gt;&lt;br&gt;MongoDB 各平台下载地址：&lt;a href=&quot;https://www.mongodb.com/download-center#community&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.mongodb.com/download-center#community&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;+
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.ittrading.cn/2018/01/16/Spring%E6%A1%86%E6%9E%B6%E4%B9%8BIOC(%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC)/"/>
    <id>http://blog.ittrading.cn/2018/01/16/Spring框架之IOC(控制反转)/</id>
    <published>2018-01-16T09:29:05.220Z</published>
    <updated>2018-01-16T09:56:07.016Z</updated>
    
    <content type="html"><![CDATA[<h2 id="title-Spring框架之IOC-控制反转"><a href="#title-Spring框架之IOC-控制反转" class="headerlink" title="title: Spring框架之IOC(控制反转)"></a>title: Spring框架之IOC(控制反转)</h2><p>[TOC]</p><p>##第一章Spring框架简介<br>IOC(控制反转)和AOP(面向方面编程)作为Spring框架的两个核心，很好地实现了解耦合。所以，简单来说，Spring是一个轻量级的控制反转（IoC）和面向切面（AOP）的容器框架。</p><p>spring的基本框架主要包含六大模块：DAO、ORM、AOP、JEE、WEB、CORE</p><p><excerpt in="" index="" |="" 首页摘要=""><br>+<a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""><br><img src="http://img.blog.csdn.net/20170525210328978?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDQyNzM5MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></the></p><blockquote><p>Spring DAO：Spring提供了对JDBC的操作支持：JdbcTemplate模板工具类 。</p><p>Spring ORM：Spring可以与ORM框架整合。例如Spring整合Hibernate框架，其中Spring还提供HibernateDaoSupport工具类，简化了Hibernate的操作 。</p><p>Spring WEB：Spring提供了对Struts、Springmvc的支持，支持WEB开发。与此同时Spring自身也提供了基于MVC的解决方案 。</p><p>Spring  AOP：Spring提供面向切面的编程，可以给某一层提供事务管理，例如在Service层添加事物控制 。</p><p>Spring   JEE：J2EE开发规范的支持，例如EJB 。</p><p>Spring Core：提供IOC容器对象的创建和处理依赖对象关系 。</p></blockquote><p>##第二章IOC(控制反转)和DI(依赖注入)<br><strong>IOC：也即控制反转，DI即依赖注入，控制反转IOC和依赖注入DI其实就是同个概念的两个不同角度的解释。</strong><br><strong>控制反转可以理解为获取依赖对象的控制反转过来。</strong>有反转的概念自然就有正转的概念。</p><p>若有两个类，类A和类B，若类A依赖与类B，则类A要获取类B的方法，这时我们可以按照传统的JavaSE思想，在A类里，写代码<code>B b = new B();</code>，通过new关键字获取A类的依赖对象，或者通过工厂模式进行获取，当然还有等等其它方法。这些方法，就属于正转的方法，因为A类获取B类就是通过主动的方法进行获取的，统称为正转的方法。</p><p>然后，什么是反转呢？既然正转是主动的方式，那么反转就是被动的方式。也即我们要获取某个类的依赖对象，不需要类主动去获取。然后在Spring框架里是怎么实现的呢？在Spring框架里，实现IOC，<strong>是通过IOC容器实现的，由IOC容器负责创建和获取依赖对象，对象只是被动地接受依赖对象。</strong></p><p>比如我们要在一个客户端类里获取用户信息类，下图给出正转的方式</p><p><img src="http://img.blog.csdn.net/20170525211519400?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDQyNzM5MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>有了IOC容器之后，获取依赖对象的方式就变成如图所示了</p><p><img src="http://img.blog.csdn.net/20170525211902580?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDQyNzM5MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>IOC是一种很好的解耦合思想，在软件开发中有很好的作用，不仅被应用在JavaEE里，在其它语言里同样适用。</p><p><img src="http://img.blog.csdn.net/20170525212335988?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDQyNzM5MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>##第三章IOC控制反转实现的方式<br>在Spring框架中实现IOC主要有三种方法。</p><ul><li>XML配置方式</li><li>注解方式</li><li><p>自动装配方式</p><p>###3.1XML配置方式</p></li></ul><p>现在基于传统XML配置方式实现的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package com.test;</span><br><span class="line"> </span><br><span class="line">public interface IUserDAO &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package com.test;</span><br><span class="line"> </span><br><span class="line">public class UserDAOImpl implements IUserDAO &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Service类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"> </span><br><span class="line">public class UserService &#123;</span><br><span class="line"> IUserDAO userDAO;</span><br><span class="line">  </span><br><span class="line"> public UserService() &#123;</span><br><span class="line">  //加载xml配置</span><br><span class="line">  ApplicationContext ctx=new   ClassPathXmlApplicationContext(&quot;application.xml&quot;);</span><br><span class="line">  //从容器中获得id为userdao的bean</span><br><span class="line">  userDAO=(IUserDAO)ctx.getBean(&quot;userdao&quot;);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bean配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line"> xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line"> xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line"> xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">  http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"> &lt;bean id=&quot;userdao&quot; class=&quot;com.test.UserDAO&quot;&gt;&lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p><p>###3.2注解方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package com.test;</span><br><span class="line"> </span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import org.springframework.stereotype.Repository;</span><br><span class="line"> </span><br><span class="line">@Component(&quot;userDao&quot;)</span><br><span class="line">public class UserDAO implements IUserDAO &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Service类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.test;</span><br><span class="line"> </span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"> </span><br><span class="line">//@Component</span><br><span class="line">@Service</span><br><span class="line">public class UserService &#123;</span><br><span class="line"> IUserDAO userDAO;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Application.xml里开启注解扫描</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line"> xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line"> xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line"> xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line"> xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">  http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">  http://www.springframework.org/schema/context</span><br><span class="line">  http://www.springframework.org/schema/context/spring-context-4.3.xsd&quot;&gt;</span><br><span class="line">  &lt;context:component-scan base-package=&quot;com.test&quot;&gt;&lt;/context:component-scan&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>采用注解的方式，比起xml配置方式更加简洁，不然也要注意耦合方面</p><blockquote><p>除了@Component外，Spring提供了3个功能基本和@Component等效的注解，分别对应于用于对DAO，Service，和Controller进行注解。<br>1：@Repository 用于对DAO实现类进行注解。<br>2：@Service 用于对业务层注解，但是目前该功能与 @Component 相同。<br>3：@Constroller用于对控制层注解，但是目前该功能与 @Component 相同。</p></blockquote><p>###3.3自动装配方式<br>下面介绍IOC实现的另外一种方式，自动装配方式，这种方式也是用的比较多的。也即注解方式和XML方式的混合使用。</p><p>实现自动转配需要两个步骤：<br>•    组件扫描（component scanning）:Spring会自动发现应用上下文中所创建的bean<br>•    自动装配（autowiring）：Spring自动满足bean之间的依赖</p><p>在xml里配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 自动扫描的包名 --&gt;</span><br><span class="line">&lt;context:component-scan base-package=&quot;com.test&quot; /&gt;</span><br><span class="line">&lt;!-- 默认的注解映射的支持 --&gt;</span><br><span class="line">&lt;mvc:annotation-driven /&gt;</span><br></pre></td></tr></table></figure><p>对于开启注解的方式， <code>&lt;context:componetn-scan&gt;</code>和<code>&lt;context:annotation-config&gt;</code>的异同，可以参考我的博客,<a href="http://blog.csdn.net/u014427391/article/details/72722797" target="_blank" rel="noopener">http://blog.csdn.net/u014427391/article/details/72722797</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface UserService &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Service(&quot;userService&quot;)</span><br><span class="line">public class UserServiceImpl implements UserService&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class UserController&#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    UserService userService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>@Autowired，该注解的作用是：可以对成员变量、方法和构造函数进行注解，来完成自动装配的工作，通俗来说就是会根据类型从容器中自动查到到一个Bean给bookDAO字段。@Autowired是根据类型进行自动装配的，如果需要按名称进行装配，则需要配合@Qualifier。另外可以使用其它注解，</p><p>@ Resource ：等同于@Qualifier</p><p>@Inject：等同于@ Autowired。</p><p>@Service用于注解业务层组件（我们通常定义的service层就用这个）</p><p>@Controller用于注解控制层组件（如struts中的action）</p><p>@Repository用于注解数据访问组件，即DAO组件</p><p>@Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行注解。</p></blockquote><p>引用自:<a href="http://www.52codes.net/article/40150.html" target="_blank" rel="noopener">http://www.52codes.net/article/40150.html</a></p><blockquote><p>装配注解主要有：@Autowired、@Qualifier、@Resource，它们的特点是：</p><p>1、@Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入；</p><p>2、@Autowired默认是按照类型装配注入的，如果想按照名称来转配注入，则需要结合@Qualifier一起使用；</p><p>3、@Resource注解是又J2EE提供，而@Autowired是由spring提供，故减少系统对spring的依赖建议使用@Resource的方式；如果Maven项目是1.5的JRE则需换成更高版本的。</p><p>4、@Resource和@Autowired都可以书写注解在字段或者该字段的setter方法之上</p><p>5、@Autowired 可以对成员变量、方法以及构造函数进行注释，而 @Qualifier 的注解对象是成员变量、方法入参、构造函数入参。</p><p>6、@Qualifier(“XXX”) 中的 XX是 Bean 的名称，所以 @Autowired 和 @Qualifier 结合使用时，自动注入的策略就从 byType 转变成 byName 了。</p><p>7、@Autowired 注释进行自动注入时，Spring 容器中匹配的候选 Bean 数目必须有且仅有一个，通过属性required可以设置非必要。</p><p>8、@Resource装配顺序<br>　　8.1. 如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常<br>　　8.2. 如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常<br>　　8.3. 如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常<br>　　8.4. 如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配；</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;title-Spring框架之IOC-控制反转&quot;&gt;&lt;a href=&quot;#title-Spring框架之IOC-控制反转&quot; class=&quot;headerlink&quot; title=&quot;title: Spring框架之IOC(控制反转)&quot;&gt;&lt;/a&gt;title: Spring框架之IOC(控制反转)&lt;/h2&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;##第一章Spring框架简介&lt;br&gt;IOC(控制反转)和AOP(面向方面编程)作为Spring框架的两个核心，很好地实现了解耦合。所以，简单来说，Spring是一个轻量级的控制反转（IoC）和面向切面（AOP）的容器框架。&lt;/p&gt;
&lt;p&gt;spring的基本框架主要包含六大模块：DAO、ORM、AOP、JEE、WEB、CORE&lt;/p&gt;
&lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;+
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.ittrading.cn/2018/01/16/IBM%20WebSphere%20ESB%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://blog.ittrading.cn/2018/01/16/IBM WebSphere ESB入门指南/</id>
    <published>2018-01-16T09:28:57.678Z</published>
    <updated>2018-01-16T09:44:24.270Z</updated>
    
    <content type="html"><![CDATA[<h2 id="title-IBM-WebSphere-ESB入门指南"><a href="#title-IBM-WebSphere-ESB入门指南" class="headerlink" title="title: IBM WebSphere ESB入门指南"></a>title: IBM WebSphere ESB入门指南</h2><p>[TOC]</p><p>##第一章 ESB介绍<br>本博客介绍一款ESB产品，IBM WebSphere ESB。ESB(Enterprise Service Bus)也即企业服务总线。ESB有很多产品，IBM的IBM WebSphere就是其中一款。ESB是传统中间件技术与XML、Web服务等技术结合的产物。虽然现在基于RPC的微服务结构兴起，但是ESB作为传统的解耦合技术。在一些企业里还是有应用的。</p><h3 id="1-1-为什么使用ESB"><a href="#1-1-为什么使用ESB" class="headerlink" title="1.1 为什么使用ESB"></a>1.1 为什么使用ESB</h3><p>在一个企业里必然有很多系统，但是不是操作系统之间的数据传输格式、传输协议等等都是不相同的。这样的话，不同系统之间调用肯定是非常复杂的，接口的维护费用肯定是很庞大的，这时企业服务总线ESB应运而生。</p><p><excerpt in="" index="" |="" 首页摘要=""><br>+<a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""><br><img src="http://img.blog.csdn.net/20170607090834736?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDQyNzM5MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></the></p><h3 id="1-2-ESB担任的角色"><a href="#1-2-ESB担任的角色" class="headerlink" title="1.2 ESB担任的角色"></a>1.2 ESB担任的角色</h3><p>中介、路由转发、格式转换、协议转换、安全控制</p><h3 id="1-3-ESB提供的服务"><a href="#1-3-ESB提供的服务" class="headerlink" title="1.3 ESB提供的服务"></a>1.3 ESB提供的服务</h3><ul><li>传输服务<br>安全、可靠的数据传输<br>持久性/非持久性<br>同步/异步</li><li>仲裁服务<br>基于内容路由<br>数据格式转换<br>通信协议转换</li><li>事件服务<br>事件发现和发布<br>事件的触发和传递</li></ul><h2 id="第二章-IBM-WebSphere-ESB开发"><a href="#第二章-IBM-WebSphere-ESB开发" class="headerlink" title="第二章 IBM WebSphere ESB开发"></a>第二章 IBM WebSphere ESB开发</h2><h3 id="2-1-IBM-WebSphere的优势"><a href="#2-1-IBM-WebSphere的优势" class="headerlink" title="2.1 IBM WebSphere的优势"></a>2.1 IBM WebSphere的优势</h3><ul><li><p>交易完整性保证<br>支持不同层次的交易完整性要求，例如：可以设定整个消息流为一个完整的交易，当某一环节发生错误时，整个消息流回滚，保证数据一致性；</p></li><li><p>高可靠性和高扩展性<br>单节点：<br>多节点：强大的Cluster功能</p></li><li><p>具有理解和管理各类系统的能力<br>支持统一的监控和管理框架：Common Event Infrastructure<br>利用Tivoli相关产品进行全面的系统监控和管理</p></li><li><p>开发简单</p></li></ul><h3 id="2-2-IBM-WebSphere-ESB开发"><a href="#2-2-IBM-WebSphere-ESB开发" class="headerlink" title="2.2 IBM WebSphere ESB开发"></a>2.2 IBM WebSphere ESB开发</h3><p>开发软件的话可以去IBM官网下载<a href="https://www.ibm.com/developerworks/cn/，因为IBM的产品是非开源的，一般是通过企业合作的。" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/，因为IBM的产品是非开源的，一般是通过企业合作的。</a><br>本博客介绍IBM IIB创建一个基本的ESB消息流，本指南所有涉及到的相关技术点都是围绕该消息流展开描述的。使用IBM IIB可以很快的实现。<br>【创建工程】<br>第一步：创建工程<br>启动IIB Tookit ，建个名称为StoreMdata的工程</p><p>第二步：创建消息流<br>创建名为StoreMdataFlow的消息流，这样一个没有任何功能的ESB消息流就创建好了<br><img src="http://img.blog.csdn.net/20170607100550844?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDQyNzM5MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>第三步：创建消息集<br>创建名为StoreMdataMessageSet的消息集，鼠标右键点击工程名StoreMdata，找到菜单：【新建】-&gt;【其他】双击弹出如下图对话框，选择消息集<br><img src="http://img.blog.csdn.net/20170607100828270?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDQyNzM5MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>点击下一步，输入名称<br>可以看出此时消息集还处于“独立资源”中，我们要把它合并到工程“StoreMdata”中去，点击项目，右键，找到Manage included projects(管理应用程序中包含的项)<br>将之前创建好的消息集（StoreMdataZMessageSet）勾选上，点击ok，然后消息集就添加到工程中来了。<br><img src="http://img.blog.csdn.net/20170607101215957?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDQyNzM5MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>【ESB消息流开发】</p><p>在IIB中提供了诸多节点可供选择，比如</p><ul><li>基于Web Service的SOAPInput节点： </li><li>基于Websphere MQ的MQInput节点： </li><li>基于Websphere适配器的SAPInput节点： </li><li>基于Http的HTTPInput节点： </li></ul><p>IIBToolkit来开发是很简单的，只要在开发界面右侧组件栏中选择适当的组件，通过拖拽放入消息流中，便可轻松的完成消息流框架的开发，后续就需要通过连接线将所有组件串接起来，组装成一个可以提供服务并对消息进行处理，转换和路由的ESB消息流了</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;title-IBM-WebSphere-ESB入门指南&quot;&gt;&lt;a href=&quot;#title-IBM-WebSphere-ESB入门指南&quot; class=&quot;headerlink&quot; title=&quot;title: IBM WebSphere ESB入门指南&quot;&gt;&lt;/a&gt;title: IBM WebSphere ESB入门指南&lt;/h2&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;##第一章 ESB介绍&lt;br&gt;本博客介绍一款ESB产品，IBM WebSphere ESB。ESB(Enterprise Service Bus)也即企业服务总线。ESB有很多产品，IBM的IBM WebSphere就是其中一款。ESB是传统中间件技术与XML、Web服务等技术结合的产物。虽然现在基于RPC的微服务结构兴起，但是ESB作为传统的解耦合技术。在一些企业里还是有应用的。&lt;/p&gt;
&lt;h3 id=&quot;1-1-为什么使用ESB&quot;&gt;&lt;a href=&quot;#1-1-为什么使用ESB&quot; class=&quot;headerlink&quot; title=&quot;1.1 为什么使用ESB&quot;&gt;&lt;/a&gt;1.1 为什么使用ESB&lt;/h3&gt;&lt;p&gt;在一个企业里必然有很多系统，但是不是操作系统之间的数据传输格式、传输协议等等都是不相同的。这样的话，不同系统之间调用肯定是非常复杂的，接口的维护费用肯定是很庞大的，这时企业服务总线ESB应运而生。&lt;/p&gt;
&lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;+
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.ittrading.cn/2018/01/16/%E4%BC%81%E4%B8%9A%E6%9C%8D%E5%8A%A1%E6%80%BB%E7%BA%BFESB%E7%AE%80%E4%BB%8B/"/>
    <id>http://blog.ittrading.cn/2018/01/16/企业服务总线ESB简介/</id>
    <published>2018-01-16T09:28:47.940Z</published>
    <updated>2018-01-16T09:55:32.330Z</updated>
    
    <content type="html"><![CDATA[<h2 id="title-企业服务总线ESB简介"><a href="#title-企业服务总线ESB简介" class="headerlink" title="title : 企业服务总线ESB简介"></a>title : 企业服务总线ESB简介</h2><p>[TOC]</p><h3 id="ESB介绍"><a href="#ESB介绍" class="headerlink" title="ESB介绍"></a>ESB介绍</h3><p>本博客介绍一款ESB产品，IBM WebSphere ESB。ESB(Enterprise Service Bus)也即企业服务总线。ESB有很多产品，IBM的IBM WebSphere就是其中一款。ESB是传统中间件技术与XML、Web服务等技术结合的产物。虽然现在基于RPC的微服务结构兴起，但是ESB作为传统的解耦合技术。在一些企业里还是有应用的。</p><h3 id="为什么使用ESB"><a href="#为什么使用ESB" class="headerlink" title="为什么使用ESB"></a>为什么使用ESB</h3><p>在一个企业里必然有很多系统，但是不是操作系统之间的数据传输格式、传输协议等等都是不相同的。这样的话，不同系统之间调用肯定是非常复杂的，接口的维护费用肯定是很庞大的，这时企业服务总线ESB应运而生。</p><p><excerpt in="" index="" |="" 首页摘要=""><br>+<a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""><br><img src="http://img.blog.csdn.net/20170607090834736?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDQyNzM5MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></the></p><h3 id="ESB担任的角色"><a href="#ESB担任的角色" class="headerlink" title="ESB担任的角色"></a>ESB担任的角色</h3><p>中介、路由转发、格式转换、协议转换、安全控制</p><p>###ESB应该有哪些服务？</p><ul><li>传输服务<br>安全、可靠的数据传输<br>永久性/非永久性<br>同步/异步</li><li>仲裁服务<br>路由<br>格式转换</li><li>事件服务<br>事件发现和发布<br>Publish / Subscribe</li></ul><p>###ESB实施方式<br>ESB实施方式包括：<br>1) ESB调度使用ESB对接各系统数据库同步(ESB为WebService服务接口，主要实现数据库的读写数据功能，如获取系统数据库A的数据，传输写入到系统数据库B，完成数据的同步操作)；<br>    2) 各系统提供接口通过ESB对接。</p><p>###为什么不采用传统架构，而是采用ESB总线方案</p><p> <img src="http://img.blog.csdn.net/20170703100131115?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDQyNzM5MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>图1.2 ESB直接对接系统<br>简介：两个系统间需要对接，讨论需求，最终确定确定接口列表、接口协议、接口格式，系统开发人员开发相关接口，通过ESB直接进行对接。<br>优点：系统之间直接对接调用，根据需要时即可调用；不需要经过OPESB数据同步接口，省去了一个中间的数据传输环节，节省维护成本；<br>缺点：需要系统开发人员进行接口开发，增加开发人员工作量与开发成本。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;title-企业服务总线ESB简介&quot;&gt;&lt;a href=&quot;#title-企业服务总线ESB简介&quot; class=&quot;headerlink&quot; title=&quot;title : 企业服务总线ESB简介&quot;&gt;&lt;/a&gt;title : 企业服务总线ESB简介&lt;/h2&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;ESB介绍&quot;&gt;&lt;a href=&quot;#ESB介绍&quot; class=&quot;headerlink&quot; title=&quot;ESB介绍&quot;&gt;&lt;/a&gt;ESB介绍&lt;/h3&gt;&lt;p&gt;本博客介绍一款ESB产品，IBM WebSphere ESB。ESB(Enterprise Service Bus)也即企业服务总线。ESB有很多产品，IBM的IBM WebSphere就是其中一款。ESB是传统中间件技术与XML、Web服务等技术结合的产物。虽然现在基于RPC的微服务结构兴起，但是ESB作为传统的解耦合技术。在一些企业里还是有应用的。&lt;/p&gt;
&lt;h3 id=&quot;为什么使用ESB&quot;&gt;&lt;a href=&quot;#为什么使用ESB&quot; class=&quot;headerlink&quot; title=&quot;为什么使用ESB&quot;&gt;&lt;/a&gt;为什么使用ESB&lt;/h3&gt;&lt;p&gt;在一个企业里必然有很多系统，但是不是操作系统之间的数据传输格式、传输协议等等都是不相同的。这样的话，不同系统之间调用肯定是非常复杂的，接口的维护费用肯定是很庞大的，这时企业服务总线ESB应运而生。&lt;/p&gt;
&lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;+
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.ittrading.cn/2018/01/16/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97kafka%E5%8E%9F%E7%90%86%E7%AE%80%E4%BB%8B/"/>
    <id>http://blog.ittrading.cn/2018/01/16/分布式消息队列kafka原理简介/</id>
    <published>2018-01-16T09:28:39.756Z</published>
    <updated>2018-01-16T09:55:44.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="title-分布式消息队列kafka原理简介"><a href="#title-分布式消息队列kafka原理简介" class="headerlink" title="title : 分布式消息队列kafka原理简介"></a>title : 分布式消息队列kafka原理简介</h2><p>[TOC]</p><p>##kafka原理简介<br>Kafka是由LinkedIn开发的一个分布式的消息系统，使用Scala编写，它以可水平扩展和高吞吐率而被广泛使用。目前越来越多的开源分布式处理系统如Cloudera、Apache Storm、Spark都支持与Kafka集成。<br>消息的发布描述为producer，消息的订阅描述为consumer，将中间的存储阵列称作broker(代理)。kafka是linkedin用于日志处理的分布式消息队列，同时支持离线和在线日志处理。kafka对消息保存时根据Topic进行归类，发送消息者就是Producer，消息接受者就是Consumer，每个kafka实例称为broker。然后三者都通过Zookeeper进行协调。<br>也即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、启动zookeeper的server</span><br><span class="line">2、启动kafka的server</span><br><span class="line">3、Producer生产数据，然后通过zookeeper找到broker，再讲数据push到broker进行保存</span><br><span class="line">4、Consumer通过zookeeper找到broker，然后再主动pull数据</span><br></pre></td></tr></table></figure><p><excerpt in="" index="" |="" 首页摘要=""><br>+<a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""><br>kafka存储是基于硬盘存储的，然而却有着快速的读写效率，一个 67200rpm STAT RAID5 的阵列，线性读写速度是 300MB/sec，如果是随机读写，速度则是 50K/sec。<br>虽然都知道内存读取速度会明显快于硬盘读写速度，但是kafka却通过线性读写的方式实现快速地读写。<br><img src="http://img.blog.csdn.net/20170712161517067?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDQyNzM5MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></the></p><h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><p>学习kafka一定要理解好Topic，每个Topic被分成多个partition(区)。每条消息在partition中的位置称为offset(偏移量)，类型为long型数字。消息即使被消费了，也不会被立即删除，而是根据broker里的设置，保存一定时间后再清除，比如log文件设置存储两天，则两天后，不管消息是否被消费，都清除。</p><p><img src="http://img.blog.csdn.net/20170712150728482?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDQyNzM5MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h3><p>broker也即中间的存储队列。我们将消息的収布（publish）暂时称作 producer，将消息的订阅（subscribe）表述为consumer，将中间的存储阵列称作 broker(代理)。</p><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>每个consumer属于一个consumer group。在kafka中，一个partition的消息只会被group中的一个consumer消费；可以认为一个group就是一个“订阅者”。一个Topic中的每个partition只会被一个“订阅者”中的一个consumer消费。</p><h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><p>kafka集群几乎不需要维护任何Consumer和Producer的信息。这些信息由Zookeeper保存。发送到Topic的消息，只会被订阅此Topic的每个group中的一个consumer消费。</p><h2 id="Kafka优点"><a href="#Kafka优点" class="headerlink" title="Kafka优点"></a>Kafka优点</h2><p>Kafka好处：转自<a href="http://www.infoq.com/cn/articles/kafka-analysis-part-1" target="_blank" rel="noopener">InfoQ：Kafka剖析</a></p><ul><li><p>解耦<br>在项目启动之初来预测将来项目会碰到什么需求，是极其困难的。消息系统在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口。这允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。</p></li><li><p>冗余<br>有些情况下，处理数据的过程会失败。除非数据被持久化，否则将造成丢失。消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。许多消息队列所采用的”插入-获取-删除”范式中，在把一个消息从队列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕。</p></li><li><p>扩展性<br>因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，只要另外增加处理过程即可。不需要改变代码、不需要调节参数。扩展就像调大电力按钮一样简单。</p></li><li><p>灵活性 &amp; 峰值处理能力<br>在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见；如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。</p></li><li><p>可恢复性<br>系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。</p></li><li><p>顺序保证<br>在大多使用场景下，数据处理的顺序都很重要。大部分消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。Kafka保证一个Partition内的消息的有序性。</p></li><li><p>缓冲<br>在任何重要的系统中，都会有需要不同的处理时间的元素。例如，加载一张图片比应用过滤器花费更少的时间。消息队列通过一个缓冲层来帮助任务最高效率的执行。写入队列的处理会尽可能的快速。该缓冲有助于控制和优化数据流经过系统的速度。</p></li><li><p>异步通信<br>很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。</p></li></ul><h2 id="单机版安装教程"><a href="#单机版安装教程" class="headerlink" title="单机版安装教程"></a>单机版安装教程</h2><p>###1、关闭SELINUX<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/selinux/config</span><br></pre></td></tr></table></figure></p><p>对配置文件进行修改，然后按ESC键，:wq保存退出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#SELINUX=enforcing </span><br><span class="line"></span><br><span class="line">#SELINUXTYPE=targeted</span><br><span class="line"></span><br><span class="line">SELINUX=disabled #增加</span><br><span class="line"></span><br><span class="line">:wq! #保存退出</span><br></pre></td></tr></table></figure></p><p>###2、配置防火墙</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sysconfig/iptables</span><br></pre></td></tr></table></figure><p>可以看到配置文件，然后按I键，insert一行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 9092 -j ACCEPT</span><br></pre></td></tr></table></figure><p>然后按ESC键，:wq保存退出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># Firewall configuration written by system-config-firewall</span><br><span class="line"></span><br><span class="line"># Manual customization of this file is not recommended.</span><br><span class="line"></span><br><span class="line">*filter</span><br><span class="line"></span><br><span class="line">:INPUT ACCEPT [0:0]</span><br><span class="line"></span><br><span class="line">:FORWARD ACCEPT [0:0]</span><br><span class="line"></span><br><span class="line">:OUTPUT ACCEPT [0:0]</span><br><span class="line"></span><br><span class="line">-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br><span class="line"></span><br><span class="line">-A INPUT -p icmp -j ACCEPT</span><br><span class="line"></span><br><span class="line">-A INPUT -i lo -j ACCEPT</span><br><span class="line"></span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT</span><br><span class="line"></span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 9092 -j ACCEPT</span><br><span class="line"></span><br><span class="line">-A INPUT -j REJECT --reject-with icmp-host-prohibited</span><br><span class="line"></span><br><span class="line">-A FORWARD -j REJECT --reject-with icmp-host-prohibited</span><br><span class="line"></span><br><span class="line">COMMIT</span><br><span class="line"></span><br><span class="line">:wq! #保存退出</span><br></pre></td></tr></table></figure></p><h3 id="3、安装JDK"><a href="#3、安装JDK" class="headerlink" title="3、安装JDK"></a>3、安装JDK</h3><p>如果有安装yum的话，一般可以使用yum安装，下面给出网上一篇很不错的jdk安装教程，建议Linux安装的可以去linux公社找找教程<br><a href="http://www.linuxidc.com/Linux/2013-04/83520.htm" target="_blank" rel="noopener">CentOS6安装JDK</a></p><p>###4、下载安装Kafka<br>cd进入相应文件夹，一般安装到/usr/local/src<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src</span><br></pre></td></tr></table></figure></p><p>wget下载文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://archive.apache.org/dist/kafka/0.8.2.1/kafka_2.11-0.8.2.1.tgz</span><br></pre></td></tr></table></figure></p><p>解压</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf kafka_2.11-0.8.2.1.tgz</span><br></pre></td></tr></table></figure><p>移动到安装目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv kafka_2.11-0.8.2.1 /usr/local/kafka</span><br></pre></td></tr></table></figure><p>###5、配置Kafka</p><p>创建Kafka日志文件存放文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/local/kafka/logs/kafka</span><br></pre></td></tr></table></figure><p>cd配置文件目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/kafka/config</span><br></pre></td></tr></table></figure><p>VI编辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi server.properties</span><br></pre></td></tr></table></figure><p>修改配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">broker.id=0</span><br><span class="line"></span><br><span class="line">port=9092 #端口号</span><br><span class="line"></span><br><span class="line">host.name=127.0.0.1 #服务器IP地址，修改为自己的服务器IP</span><br><span class="line"></span><br><span class="line">log.dirs=/usr/local/kafka/logs/kafka #日志存放路径，上面创建的目录</span><br><span class="line"></span><br><span class="line">zookeeper.connect=localhost:2181 #zookeeper地址和端口，单机配置部署，localhost:2181</span><br><span class="line"></span><br><span class="line">:wq! #保存退出</span><br></pre></td></tr></table></figure><p>###6、Zookeeper配置<br>创建一个目录安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/local/kafka/zookeeper</span><br></pre></td></tr></table></figure><p>创建一个Zookeeper日志存放目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/local/kafka/logs/zookeeper</span><br></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/kafka/config</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi zookeeper.properties</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dataDir=/usr/local/kafka/zookeeper #zookeeper数据目录</span><br><span class="line"></span><br><span class="line">dataLogDir=/usr/local/kafka/log/zookeeper #zookeeper日志目录</span><br><span class="line"></span><br><span class="line">clientPort=2181</span><br><span class="line"></span><br><span class="line">maxClientCnxns=100</span><br><span class="line"></span><br><span class="line">tickTime=2000</span><br><span class="line"></span><br><span class="line">initLimit=10</span><br><span class="line"></span><br><span class="line">syncLimit=5</span><br><span class="line"></span><br><span class="line">:wq! #保存退出</span><br></pre></td></tr></table></figure><p>###7、脚本编写</p><p>编写kafka的start脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/kafka</span><br></pre></td></tr></table></figure></p><p>使用vi创建脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi kafkastart.sh</span><br></pre></td></tr></table></figure></p><p>加入脚本代码，&amp;符号表示在后台执行，然后:wq保存退出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">#启动zookeeper</span><br><span class="line"></span><br><span class="line">/usr/local/kafka/bin/zookeeper-server-start.sh /usr/local/kafka/config/zookeeper.properties &amp;</span><br><span class="line"></span><br><span class="line">sleep 3 #等3秒后执行</span><br><span class="line"></span><br><span class="line">#启动kafka</span><br><span class="line"></span><br><span class="line">/usr/local/kafka/bin/kafka-server-start.sh /usr/local/kafka/config/server.properties &amp;</span><br></pre></td></tr></table></figure></p><p>编写kafka的stop脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi kafkastop.sh</span><br></pre></td></tr></table></figure><p>脚本代码如，同样是:wq保存退出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">#关闭zookeeper</span><br><span class="line"></span><br><span class="line">/usr/local/kafka/bin/zookeeper-server-stop.sh /usr/local/kafka/config/zookeeper.properties &amp;</span><br><span class="line"></span><br><span class="line">sleep 3 #等3秒后执行</span><br><span class="line"></span><br><span class="line">#关闭kafka</span><br><span class="line"></span><br><span class="line">/usr/local/kafka/bin/kafka-server-stop.sh /usr/local/kafka/config/server.properties &amp;</span><br></pre></td></tr></table></figure></p><p>添加脚本执行权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod +x kafkastart.sh</span><br><span class="line"></span><br><span class="line">chmod +x kafkastop.sh</span><br></pre></td></tr></table></figure><p>###8、配置脚本开机自行启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/rc.d/rc.local</span><br></pre></td></tr></table></figure><p>设置开机时脚本在后台执行，使用&amp;符号<br>将如下代码添加到rc.local里，同样使用VI编辑器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh /usr/local/kafka/kafkastart.sh &amp;</span><br></pre></td></tr></table></figure></p><p>：wq保存退出</p><p>###9、启动kafka<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh /usr/local/kafka/kafkastart.sh #启动kafka</span><br></pre></td></tr></table></figure></p><p>###10、创建topic</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">usr/local/kafka/bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test</span><br><span class="line"></span><br><span class="line">/usr/local/kafka/bin/kafka-topics.sh --list --zookeeper localhost:2181 test</span><br><span class="line"></span><br><span class="line">/usr/local/kafka/bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test --from-beginning</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;title-分布式消息队列kafka原理简介&quot;&gt;&lt;a href=&quot;#title-分布式消息队列kafka原理简介&quot; class=&quot;headerlink&quot; title=&quot;title : 分布式消息队列kafka原理简介&quot;&gt;&lt;/a&gt;title : 分布式消息队列kafka原理简介&lt;/h2&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;##kafka原理简介&lt;br&gt;Kafka是由LinkedIn开发的一个分布式的消息系统，使用Scala编写，它以可水平扩展和高吞吐率而被广泛使用。目前越来越多的开源分布式处理系统如Cloudera、Apache Storm、Spark都支持与Kafka集成。&lt;br&gt;消息的发布描述为producer，消息的订阅描述为consumer，将中间的存储阵列称作broker(代理)。kafka是linkedin用于日志处理的分布式消息队列，同时支持离线和在线日志处理。kafka对消息保存时根据Topic进行归类，发送消息者就是Producer，消息接受者就是Consumer，每个kafka实例称为broker。然后三者都通过Zookeeper进行协调。&lt;br&gt;也即：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1、启动zookeeper的server&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2、启动kafka的server&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3、Producer生产数据，然后通过zookeeper找到broker，再讲数据push到broker进行保存&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4、Consumer通过zookeeper找到broker，然后再主动pull数据&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;+
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.ittrading.cn/2018/01/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B/"/>
    <id>http://blog.ittrading.cn/2018/01/16/设计模式之代理模式简介/</id>
    <published>2018-01-16T09:28:29.542Z</published>
    <updated>2018-01-16T10:02:12.279Z</updated>
    
    <content type="html"><![CDATA[<h2 id="title-设计模式之代理模式简介"><a href="#title-设计模式之代理模式简介" class="headerlink" title="title : 设计模式之代理模式简介"></a>title : 设计模式之代理模式简介</h2><p>[TOC]</p><h2 id="第一章-前言"><a href="#第一章-前言" class="headerlink" title="第一章 前言"></a>第一章 前言</h2><p>在某些情况下，一个客户不想或者不能直接引用一个对象，此时可以通过一个称之为“代理”的第三者来实现间接引用。代理对象可以在客户端和目标对象之间起到中介的作用，并且可以通过代理对象去掉客户不能看到的内容和服务或者添加客户需要的额外服务。<br>代理模式的角色分为：<br>主题接口： 即代理类的所实现的行为接口。<br>目标对象： 也就是被代理的对象。<br>代理对象： 用来封装真是主题类的代理类<br>客户端：即用来实现的类</p><p><excerpt in="" index="" |="" 首页摘要=""><br>+<a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""><br><img src="http://img.blog.csdn.net/20170715110926663?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDQyNzM5MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></the></p><blockquote><p>代理模式分为静态代理和动态代理 •    静态代理:静态代理就是<strong>编译阶段就生成代理类</strong>来完成对代理对象的一系列操作。<br>•    动态代理:动态代理是指在<strong>运行时动态生成代理类</strong>。即，代理类的字节码将在运行时生成并载入当前代理的 ClassLoader。</p></blockquote><h2 id="第二章-静态代理"><a href="#第二章-静态代理" class="headerlink" title="第二章 静态代理"></a>第二章 静态代理</h2><p>静态代理：静态代理就是<strong>编译阶段就生成代理类</strong>来完成对代理对象的一系列操作。<br>主题接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public   interface Subject  &#123;    </span><br><span class="line">abstract   public   void  request(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>目标对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public   class  RealSubject  implements Subject  &#123;             </span><br><span class="line">   public   void  request()  &#123;         </span><br><span class="line">   System.out.println( &quot; From real subject. &quot; );     </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public   class  StaticProxySubject  implements Subject  &#123; </span><br><span class="line">    private  RealSubject  realSubject;  // 以真实角色作为代理角色的属性  </span><br><span class="line">    public  ProxySubject()  &#123; &#125;  </span><br><span class="line">    public  void  request()  &#123;  // 该方法封装了真实对象的request方法        </span><br><span class="line">    //懒加载，用的时候才加载</span><br><span class="line">if ( realSubject  ==   null  )  &#123; </span><br><span class="line">realSubject  =   new  RealSubject();        </span><br><span class="line">&#125;   </span><br><span class="line">realSubject.request();  // 此处执行真实对象的request方法   </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编写客户端类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Client&#123;</span><br><span class="line">StaticProxySubject sps = new StaticProxySubject();</span><br><span class="line">sps.request();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第三章-动态代理"><a href="#第三章-动态代理" class="headerlink" title="第三章 动态代理"></a>第三章 动态代理</h2><p>动态代理：动态代理是指在<strong>运行时动态生成代理类</strong>。即，代理类的字节码将在运行时生成并载入当前代理的 ClassLoader。<br>生成动态代理的方法有很多： JDK中自带动态代理，CGlib, javassist等。</p><h3 id="3-1-JDK动态代理"><a href="#3-1-JDK动态代理" class="headerlink" title="3.1 JDK动态代理"></a>3.1 JDK动态代理</h3><p>Proxy类。该类即为动态代理类，该类最常用的方法为：<code>public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException</code>。</p><blockquote><p>newProxyInstance()方法用于根据传入的接口类型interfaces返回一个动态创建的代理类的实例，方法中第一个参数loader表示代理类的类加载器，第二个参数interfaces表示被代理类实现的接口列表，第三个参数h表示所指派的调用处理程序类。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">public class MyInvocationHandler implements InvocationHandler &#123;</span><br><span class="line">    private Class&lt;?&gt; target;//委托类</span><br><span class="line">    public MyInvocationHandler(Class&lt;?&gt; target)&#123;</span><br><span class="line">        this.target=target;</span><br><span class="line">    &#125;</span><br><span class="line">//实际执行类bind</span><br><span class="line">    public  Object bind(Class&lt;?&gt; target)&#123;</span><br><span class="line">        //利用JDK提供的Proxy实现动态代理</span><br><span class="line">        return  Proxy.newProxyInstance(target.getClassLoader(),</span><br><span class="line">        new Class[]&#123;target&#125;,this);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object o, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">/**代理环绕**/</span><br><span class="line">        //执行实际的方法</span><br><span class="line">        Object invoke = method.invoke(target, args);</span><br><span class="line">        return invoke;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-CGLIB动态代理"><a href="#3-2-CGLIB动态代理" class="headerlink" title="3.2 CGLIB动态代理"></a>3.2 CGLIB动态代理</h3><p>CGLIB动态代理实现相关类需要在项目中导入 cglib-nodep-2.1_3.jar ，主要涉及两个类：<br>MethodInterceptor接口。它是代理实例的调用处理程序实现的接口，该接口中定义了如下方法：<code>public Object intercept(Object proxy, Method method, Object[] arg2,   MethodProxy mp);</code></p><p>intercept()方法中第一个参数proxy表示代理类，第二个参数method表示需要代理的方法，第三个参数args表示代理方法的参数数组，第四个参数mp用 来去调用被代理对象方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package com.demo;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">import net.sf.cglib.proxy.Enhancer;</span><br><span class="line">import net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line">import net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line">public class MyInterceptor implements MethodInterceptor&#123;</span><br><span class="line">    private Object target; ;//代理的目标对象</span><br><span class="line">    public MyInterceptor(Object target) &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">    &#125; </span><br><span class="line">//proxy 在其上调用方法的代理实例    method拦截的方法    args  拦截的参数</span><br><span class="line"> //invocation 用来去调用被代理对象方法</span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object proxy, Method method, Object[] args, </span><br><span class="line">                                         MethodProxy invocation) throws Throwable &#123;</span><br><span class="line">        //1.记录日志 2.时间统计开始   3.安全检查</span><br><span class="line">        Object retVal = invocation.invoke(target, args);  </span><br><span class="line">        //4.时间统计结束</span><br><span class="line">        return retVal;   </span><br><span class="line">    &#125;</span><br><span class="line">//创建代理对象的方法</span><br><span class="line">    public Object proxy(Object target) &#123;</span><br><span class="line">this.target = target;</span><br><span class="line">Enhancer enhancer = new Enhancer();//该类用于生成代理类</span><br><span class="line">enhancer.setSuperclass(this.target.getClass());//设置父类</span><br><span class="line">enhancer.setCallback(this);//设置回调用对象为本身</span><br><span class="line">return enhancer.create();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;title-设计模式之代理模式简介&quot;&gt;&lt;a href=&quot;#title-设计模式之代理模式简介&quot; class=&quot;headerlink&quot; title=&quot;title : 设计模式之代理模式简介&quot;&gt;&lt;/a&gt;title : 设计模式之代理模式简介&lt;/h2&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;第一章-前言&quot;&gt;&lt;a href=&quot;#第一章-前言&quot; class=&quot;headerlink&quot; title=&quot;第一章 前言&quot;&gt;&lt;/a&gt;第一章 前言&lt;/h2&gt;&lt;p&gt;在某些情况下，一个客户不想或者不能直接引用一个对象，此时可以通过一个称之为“代理”的第三者来实现间接引用。代理对象可以在客户端和目标对象之间起到中介的作用，并且可以通过代理对象去掉客户不能看到的内容和服务或者添加客户需要的额外服务。&lt;br&gt;代理模式的角色分为：&lt;br&gt;主题接口： 即代理类的所实现的行为接口。&lt;br&gt;目标对象： 也就是被代理的对象。&lt;br&gt;代理对象： 用来封装真是主题类的代理类&lt;br&gt;客户端：即用来实现的类&lt;/p&gt;
&lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;+
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.ittrading.cn/2018/01/16/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://blog.ittrading.cn/2018/01/16/JDK动态代理源码学习/</id>
    <published>2018-01-16T09:28:09.324Z</published>
    <updated>2018-01-16T09:56:24.192Z</updated>
    
    <content type="html"><![CDATA[<h2 id="title-JDK动态代理源码学习"><a href="#title-JDK动态代理源码学习" class="headerlink" title="title: JDK动态代理源码学习"></a>title: JDK动态代理源码学习</h2><p>继上一篇博客设计模式之代理模式学习之后<a href="http://blog.csdn.net/u014427391/article/details/75115928，本博客介绍JDK动态代理的实现原理，学习一下JDK动态代理的源码。" target="_blank" rel="noopener">http://blog.csdn.net/u014427391/article/details/75115928，本博客介绍JDK动态代理的实现原理，学习一下JDK动态代理的源码。</a><br>Proxy类。该类即为动态代理类，可以使用反编译工具查看jdk里源码。JDK动态代理实现主要由Proxy类的newProxyInstance()方法实现。实现起来很容易，但是学习都要学习原理，所以本博客主要介绍jdk动态代理实现的源码。</p><blockquote><p>newProxyInstance()方法用于根据传入的接口类型interfaces返回一个动态创建的代理类的实例，方法中第一个参数loader表示代理类的类加载器，第二个参数interfaces表示被代理类实现的接口列表，第三个参数h表示所指派的调用处理程序类。</p></blockquote><p>首先写个例子实现jdk动态代理<br>主题接口类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface IHello &#123;</span><br><span class="line">    public void sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><excerpt in="" index="" |="" 首页摘要=""><br>+<a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""><br>被代理的类：</the></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Hello implements IHello&#123;</span><br><span class="line"></span><br><span class="line">    public void sayHello() &#123;</span><br><span class="line">        System.out.println(&quot;hello!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK动态代理InvocationHandler类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">public class MyInvocationHandler implements InvocationHandler &#123;</span><br><span class="line">    private Object target;//委托类</span><br><span class="line">    public MyInvocationHandler(Object target)&#123;</span><br><span class="line">        this.target=target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object o, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">/**代理环绕**/</span><br><span class="line">        //执行实际的方法</span><br><span class="line">        Object invoke = method.invoke(target, args);</span><br><span class="line">        return invoke;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>写个类模拟字节码文件生成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by Nicky on 2017/7/20 0020.</span><br><span class="line"> */</span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</span><br><span class="line">        IHello  ihello = (IHello) Proxy.newProxyInstance(IHello.class.getClassLoader(),  //加载接口的类加载器</span><br><span class="line">                new Class[]&#123;IHello.class&#125;,      //一组接口</span><br><span class="line">                new MyInvocationHandler(new Hello())); //自定义的InvocationHandler</span><br><span class="line">        ihello.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现jdk动态代理是很容易的，不过现在介绍一下jdk源码，理解一下原理实现</p><p>下面看一下Proxy类里的newProxyInstance方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">@CallerSensitive</span><br><span class="line">   public static Object newProxyInstance(ClassLoader loader,</span><br><span class="line">                                         Class&lt;?&gt;[] interfaces,</span><br><span class="line">                                         InvocationHandler h)</span><br><span class="line">       throws IllegalArgumentException</span><br><span class="line">   &#123;</span><br><span class="line">       Objects.requireNonNull(h);</span><br><span class="line">//对象的拷贝</span><br><span class="line">       final Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">/*</span><br><span class="line"> *权限安全检查</span><br><span class="line"> */</span><br><span class="line">       final SecurityManager sm = System.getSecurityManager();</span><br><span class="line">       if (sm != null) &#123;</span><br><span class="line">           checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * Look up or generate the designated proxy class.</span><br><span class="line"> * (查找或生产指定的代理类。)</span><br><span class="line">        */</span><br><span class="line">       Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        * Invoke its constructor with the designated invocation handler.</span><br><span class="line"> * (使用指定的调用处理程序调用它的构造函数。)</span><br><span class="line">        */</span><br><span class="line">       try &#123;</span><br><span class="line">           if (sm != null) &#123;</span><br><span class="line">               checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">           &#125;</span><br><span class="line">//获取代理类的构造函数</span><br><span class="line">           final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">           final InvocationHandler ih = h;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> *onstructor、Filed、Method都继承自java.lang.reflect.AccessibleObject，</span><br><span class="line"> * 访问非public的方法或者字段都会产生IllegalAccessException异常</span><br><span class="line"> */</span><br><span class="line">if (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">               AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                   public Void run() &#123;</span><br><span class="line">                       cons.setAccessible(true);//setAccessible()为true可以绕过默认的权限检查</span><br><span class="line">                       return null;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">           &#125;</span><br><span class="line">//根据代理类的构造函数来创建代理对象</span><br><span class="line">           return cons.newInstance(new Object[]&#123;h&#125;);</span><br><span class="line">       &#125; catch (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">           throw new InternalError(e.toString(), e);</span><br><span class="line">       &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">           Throwable t = e.getCause();</span><br><span class="line">           if (t instanceof RuntimeException) &#123;</span><br><span class="line">               throw (RuntimeException) t;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               throw new InternalError(t.toString(), t);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">           throw new InternalError(e.toString(), e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>从newProxyInstance方法可以看出，生产代理类是由getProxyClass0获取或者生成的。下面看一下getProxyClass0方法，从方法可以看出如果缓存中有代理类就直接返回代理的副本，否就使用ProxyClassFactory创建代理类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Generate a proxy class.  Must call the checkProxyAccess method</span><br><span class="line">    * to perform permission checks before calling this.</span><br><span class="line">    */</span><br><span class="line">   private static Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                          Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">//接口列表数目不能超过65535,因为在class文件中，这些个数都是用4位16进制表示的，所以最大值是2的16次方-1  </span><br><span class="line">if (interfaces.length &gt; 65535) &#123;</span><br><span class="line">           throw new IllegalArgumentException(&quot;interface limit exceeded&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">// If the proxy class defined by the given loader implementing</span><br><span class="line">       // the given interfaces exists, this will simply return the cached copy;</span><br><span class="line">       // otherwise, it will create the proxy class via the ProxyClassFactory</span><br><span class="line">       //如果缓存中有代理类就直接返回代理的副本，否就使用ProxyClassFactory创建代理类</span><br><span class="line">       return proxyClassCache.get(loader, interfaces);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>proxyClassCache是一个WeakCache类型的缓存，它的构造函数有两个参数，其中一个就是用于生成代理类的ProxyClassFactory，看一下proxyClassCache.get方法的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">public V get(K key, P parameter) &#123;</span><br><span class="line">        Objects.requireNonNull(parameter);</span><br><span class="line">//清理持有弱引用的WeakHashMap这种数据结构</span><br><span class="line">        expungeStaleEntries();</span><br><span class="line">//从队列中获取cacheKey</span><br><span class="line">        Object cacheKey = CacheKey.valueOf(key, refQueue);</span><br><span class="line"></span><br><span class="line">        // lazily install the 2nd level valuesMap for the particular cacheKey</span><br><span class="line">        //懒加载的方式封装第二层valueMap，ConcurrentMap是一种线程安全的Map</span><br><span class="line">        ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap = map.get(cacheKey);</span><br><span class="line">        if (valuesMap == null) &#123;</span><br><span class="line">            ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; oldValuesMap</span><br><span class="line">                = map.putIfAbsent(cacheKey,</span><br><span class="line">                                  valuesMap = new ConcurrentHashMap&lt;&gt;());</span><br><span class="line">            if (oldValuesMap != null) &#123;</span><br><span class="line">                valuesMap = oldValuesMap;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // create subKey and retrieve the possible Supplier&lt;V&gt; stored by that</span><br><span class="line">        // subKey from valuesMap</span><br><span class="line">        Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));</span><br><span class="line">        Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class="line">        Factory factory = null;</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (supplier != null) &#123;</span><br><span class="line">                // supplier might be a Factory or a CacheValue&lt;V&gt; instance</span><br><span class="line">                //核心代码，从supplier或者value，可能返回工厂实例或者Cache实例，返回实现InvokeHandler的类并包含了所需要的信息。</span><br><span class="line">                V value = supplier.get();</span><br><span class="line">                if (value != null) &#123;</span><br><span class="line">                    return value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // else no supplier in cache</span><br><span class="line">            // or a supplier that returned null (could be a cleared CacheValue</span><br><span class="line">            // or a Factory that wasn&apos;t successful in installing the CacheValue)</span><br><span class="line"></span><br><span class="line">            // lazily construct a Factory</span><br><span class="line">            //懒加载方式构建工厂实例</span><br><span class="line">            if (factory == null) &#123;</span><br><span class="line">                factory = new Factory(key, parameter, subKey, valuesMap);</span><br><span class="line">            &#125;</span><br><span class="line">/**填充supplier**/</span><br><span class="line">            if (supplier == null) &#123;</span><br><span class="line">                supplier = valuesMap.putIfAbsent(subKey, factory);</span><br><span class="line">                if (supplier == null) &#123;</span><br><span class="line">                    // successfully installed Factory</span><br><span class="line">                    supplier = factory;</span><br><span class="line">                &#125;</span><br><span class="line">                // else retry with winning supplier</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (valuesMap.replace(subKey, supplier, factory)) &#123;</span><br><span class="line">                    // successfully replaced</span><br><span class="line">                    // cleared CacheEntry / unsuccessful Factory</span><br><span class="line">                    // with our Factory</span><br><span class="line">                    supplier = factory;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // retry with current supplier</span><br><span class="line">                    supplier = valuesMap.get(subKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>若缓存中找不到代理类，就使用ProxyClassFactory生产代理类，看一下ProxyClassFactory类的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * A factory function that generates, defines and returns the proxy class given</span><br><span class="line">    * the ClassLoader and array of interfaces.</span><br><span class="line">    */</span><br><span class="line">   private static final class ProxyClassFactory</span><br><span class="line">       implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">   &#123;</span><br><span class="line">       // prefix for all proxy class names(统一所以代理类的前缀名都以$Proxy开始)</span><br><span class="line">       private static final String proxyClassNamePrefix = &quot;$Proxy&quot;;</span><br><span class="line"></span><br><span class="line">       // next number to use for generation of unique proxy class names</span><br><span class="line">//给每个代理类名加个唯一的编号,如$Proxy0，$Proxy1等等</span><br><span class="line">       private static final AtomicLong nextUniqueNumber = new AtomicLong();</span><br><span class="line"></span><br><span class="line">       @Override</span><br><span class="line">       public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line"></span><br><span class="line">           Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class="line">           for (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">               /*</span><br><span class="line">                * Verify that the class loader resolves the name of this</span><br><span class="line">                * interface to the same Class object.</span><br><span class="line">                */</span><br><span class="line">               Class&lt;?&gt; interfaceClass = null;</span><br><span class="line">//通过类名加载每一个接口运行时的信息</span><br><span class="line">               try &#123;</span><br><span class="line">                   interfaceClass = Class.forName(intf.getName(), false, loader);</span><br><span class="line">               &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">               &#125;</span><br><span class="line">//验证使用classLoad加载的类与传入的类是否相同</span><br><span class="line">               if (interfaceClass != intf) &#123;</span><br><span class="line">                   throw new IllegalArgumentException(</span><br><span class="line">                       intf + &quot; is not visible from class loader&quot;);</span><br><span class="line">               &#125;</span><br><span class="line">               /*</span><br><span class="line">                * Verify that the Class object actually represents an</span><br><span class="line">                * interface.</span><br><span class="line"> * 验证传入的是否为接口类型，因为jdk动态代理只支持接口类型</span><br><span class="line">                */</span><br><span class="line">               if (!interfaceClass.isInterface()) &#123;</span><br><span class="line">                   throw new IllegalArgumentException(</span><br><span class="line">                       interfaceClass.getName() + &quot; is not an interface&quot;);</span><br><span class="line">               &#125;</span><br><span class="line">               /*</span><br><span class="line">                * Verify that this interface is not a duplicate.</span><br><span class="line"> * 验证接口是否重复</span><br><span class="line">                */</span><br><span class="line">               if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123;</span><br><span class="line">                   throw new IllegalArgumentException(</span><br><span class="line">                       &quot;repeated interface: &quot; + interfaceClass.getName());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           String proxyPkg = null;     // package to define proxy class in</span><br><span class="line">           int accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Record the package of a non-public proxy interface so that the</span><br><span class="line">            * proxy class will be defined in the same package.  Verify that</span><br><span class="line">            * all non-public proxy interfaces are in the same package.</span><br><span class="line"> * 验证传入的接口中有没有非public的接口，若有，就将这些接口全部放在一个包里定义</span><br><span class="line">            */</span><br><span class="line">           for (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">               int flags = intf.getModifiers();</span><br><span class="line">               if (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">                   accessFlags = Modifier.FINAL;</span><br><span class="line">                   String name = intf.getName();</span><br><span class="line">                   int n = name.lastIndexOf(&apos;.&apos;);</span><br><span class="line">//substring包名</span><br><span class="line">                   String pkg = ((n == -1) ? &quot;&quot; : name.substring(0, n + 1));</span><br><span class="line">                   if (proxyPkg == null) &#123;</span><br><span class="line">                       proxyPkg = pkg;</span><br><span class="line">                   &#125; else if (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">                       throw new IllegalArgumentException(</span><br><span class="line">                           &quot;non-public interfaces from different packages&quot;);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (proxyPkg == null) &#123;</span><br><span class="line">               // if no non-public proxy interfaces, use com.sun.proxy package</span><br><span class="line">//(如果没有非公共的代理接口，请使用com.sun.proxy包)</span><br><span class="line">               proxyPkg = ReflectUtil.PROXY_PACKAGE + &quot;.&quot;;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Choose a name for the proxy class to generate.(为代理类选择一个名称来生成)</span><br><span class="line">            */</span><br><span class="line">           long num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">//生产随机代理类的类名,$Proxy+num</span><br><span class="line">           String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">            * Generate the specified proxy class.</span><br><span class="line"> * 生产代理类的字节码文件，实现过程看generateProxyClass()方法</span><br><span class="line">            */</span><br><span class="line">           byte[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">               proxyName, interfaces, accessFlags);</span><br><span class="line">           try &#123;</span><br><span class="line">               return defineClass0(loader, proxyName,</span><br><span class="line">                                   proxyClassFile, 0, proxyClassFile.length);</span><br><span class="line">           &#125; catch (ClassFormatError e) &#123;</span><br><span class="line">               /*</span><br><span class="line">                * A ClassFormatError here means that (barring bugs in the</span><br><span class="line">                * proxy class generation code) there was some other</span><br><span class="line">                * invalid aspect of the arguments supplied to the proxy</span><br><span class="line">                * class creation (such as virtual machine limitations</span><br><span class="line">                * exceeded).</span><br><span class="line">                */</span><br><span class="line">               throw new IllegalArgumentException(e.toString());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>从ProxyClassFactory类可以看出生产字节码文件的执行代码由generateProxyClass方法执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public static byte[] generateProxyClass(final String var0, Class&lt;?&gt;[] var1, int var2) &#123;</span><br><span class="line">//新建ProxyGenerator实例，放入参数proxyName, interfaces, accessFlags，也即代理名称，接口列表，是否允许代理的flag标志</span><br><span class="line">        ProxyGenerator var3 = new ProxyGenerator(var0, var1, var2);</span><br><span class="line">        //真正实现生产字节码文件的方法</span><br><span class="line">        final byte[] var4 = var3.generateClassFile();</span><br><span class="line">        //检查是否允许生产文件，如果可以就保存class文件到本地</span><br><span class="line">        if(saveGeneratedFiles) &#123;</span><br><span class="line">            AccessController.doPrivileged(new PrivilegedAction() &#123;</span><br><span class="line">                public Void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        int var1 = var0.lastIndexOf(46);</span><br><span class="line">                        Path var2;</span><br><span class="line">                        if(var1 &gt; 0) &#123;</span><br><span class="line">                            Path var3 = Paths.get(var0.substring(0, var1).replace(&apos;.&apos;, File.separatorChar), new String[0]);</span><br><span class="line">                            Files.createDirectories(var3, new FileAttribute[0]);</span><br><span class="line">                            var2 = var3.resolve(var0.substring(var1 + 1, var0.length()) + &quot;.class&quot;);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            var2 = Paths.get(var0 + &quot;.class&quot;, new String[0]);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        Files.write(var2, var4, new OpenOption[0]);</span><br><span class="line">                        return null;</span><br><span class="line">                    &#125; catch (IOException var4x) &#123;</span><br><span class="line">                        throw new InternalError(&quot;I/O exception saving generated file: &quot; + var4x);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return var4;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>看了这么久，终于知道generateClassFile是真正执行class文件生成的方法，现在看一下generateClassFile的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">private byte[] generateClassFile() &#123;</span><br><span class="line">/**将Object类的三个方法hashCode、equals、toString都加到代理方法里，生产class文件时一起重写**/</span><br><span class="line">        this.addProxyMethod(hashCodeMethod, Object.class);</span><br><span class="line">        this.addProxyMethod(equalsMethod, Object.class);</span><br><span class="line">        this.addProxyMethod(toStringMethod, Object.class);</span><br><span class="line">        Class[] var1 = this.interfaces;</span><br><span class="line">        int var2 = var1.length;</span><br><span class="line"></span><br><span class="line">        int var3;</span><br><span class="line">        Class var4;</span><br><span class="line">        //将接口和接口下的方法对应起来</span><br><span class="line">        for(var3 = 0; var3 &lt; var2; ++var3) &#123;</span><br><span class="line">            var4 = var1[var3];</span><br><span class="line">            Method[] var5 = var4.getMethods();</span><br><span class="line">            int var6 = var5.length;</span><br><span class="line"></span><br><span class="line">            for(int var7 = 0; var7 &lt; var6; ++var7) &#123;</span><br><span class="line">                Method var8 = var5[var7];</span><br><span class="line">                this.addProxyMethod(var8, var4);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Iterator var11 = this.proxyMethods.values().iterator();</span><br><span class="line"></span><br><span class="line">        List var12;</span><br><span class="line">        //检查所有代理方法的返回类型</span><br><span class="line">        while(var11.hasNext()) &#123;</span><br><span class="line">            var12 = (List)var11.next();</span><br><span class="line">            checkReturnTypes(var12);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Iterator var15;</span><br><span class="line">        try &#123;</span><br><span class="line">        //将构造函数放在方法里，这个构造方法只有一个，即一个带有InvocationHandler实例的构造方法</span><br><span class="line">            this.methods.add(this.generateConstructor());</span><br><span class="line">            var11 = this.proxyMethods.values().iterator();</span><br><span class="line">//遍历代理方法</span><br><span class="line">            while(var11.hasNext()) &#123;</span><br><span class="line">                var12 = (List)var11.next();</span><br><span class="line">                var15 = var12.iterator();</span><br><span class="line"></span><br><span class="line">                while(var15.hasNext()) &#123;</span><br><span class="line">                    ProxyGenerator.ProxyMethod var16 = (ProxyGenerator.ProxyMethod)var15.next();</span><br><span class="line">                    //给每一个代理方法加一个Method类型的属性，数字10是class文件的标识符，代表这些属性都是private static的</span><br><span class="line">                    this.fields.add(new ProxyGenerator.FieldInfo(var16.methodFieldName, &quot;Ljava/lang/reflect/Method;&quot;, 10));</span><br><span class="line">                    //将方法都加到代理类的方法里</span><br><span class="line">                    this.methods.add(var16.generateMethod());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">//加入一个静态的类构造方法，将每一个属性初始化</span><br><span class="line">            this.methods.add(this.generateStaticInitializer());</span><br><span class="line">        &#125; catch (IOException var10) &#123;</span><br><span class="line">            throw new InternalError(&quot;unexpected I/O Exception&quot;, var10);</span><br><span class="line">        &#125;</span><br><span class="line">//方法和属性个数都不能超过65535,因为在class文件中，这些个数都是用4位16进制表示的，所以最大值是2的16次方-1  </span><br><span class="line">        if(this.methods.size() &gt; &apos;\uffff&apos;) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;method limit exceeded&quot;);</span><br><span class="line">        &#125; else if(this.fields.size() &gt; &apos;\uffff&apos;) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;field limit exceeded&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        //将类名中的.转成成斜线为了写入class文件。  </span><br><span class="line">            this.cp.getClass(dotToSlash(this.className));</span><br><span class="line">            this.cp.getClass(&quot;java/lang/reflect/Proxy&quot;);</span><br><span class="line">            var1 = this.interfaces;</span><br><span class="line">            var2 = var1.length;</span><br><span class="line"></span><br><span class="line">            for(var3 = 0; var3 &lt; var2; ++var3) &#123;</span><br><span class="line">                var4 = var1[var3];</span><br><span class="line">                this.cp.getClass(dotToSlash(var4.getName()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            this.cp.setReadOnly();</span><br><span class="line">            //开始真正的写class文件</span><br><span class="line">            ByteArrayOutputStream var13 = new ByteArrayOutputStream();</span><br><span class="line">            DataOutputStream var14 = new DataOutputStream(var13);</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">            //写入class文件的标识号，标识这是一个class文件  </span><br><span class="line">                var14.writeInt(-889275714);</span><br><span class="line">                //次版本号0</span><br><span class="line">                var14.writeShort(0);</span><br><span class="line">                //主版本号,49代表的是JDK1.5</span><br><span class="line">                var14.writeShort(49);</span><br><span class="line">                this.cp.write(var14);</span><br><span class="line">                var14.writeShort(this.accessFlags);</span><br><span class="line">                //写入代理类的类名</span><br><span class="line">                var14.writeShort(this.cp.getClass(dotToSlash(this.className)));</span><br><span class="line">                var14.writeShort(this.cp.getClass(&quot;java/lang/reflect/Proxy&quot;));</span><br><span class="line">                //写入代理类所实现的接口数量  </span><br><span class="line">                var14.writeShort(this.interfaces.length);</span><br><span class="line">                Class[] var17 = this.interfaces;</span><br><span class="line">                int var18 = var17.length;</span><br><span class="line"></span><br><span class="line">                for(int var19 = 0; var19 &lt; var18; ++var19) &#123;</span><br><span class="line">                    Class var22 = var17[var19];</span><br><span class="line">                    var14.writeShort(this.cp.getClass(dotToSlash(var22.getName())));</span><br><span class="line">                &#125;</span><br><span class="line">//写入属性个数</span><br><span class="line">                var14.writeShort(this.fields.size());</span><br><span class="line">                var15 = this.fields.iterator();</span><br><span class="line">//写入属性描述</span><br><span class="line">                while(var15.hasNext()) &#123;</span><br><span class="line">                    ProxyGenerator.FieldInfo var20 = (ProxyGenerator.FieldInfo)var15.next();</span><br><span class="line">                    var20.write(var14);</span><br><span class="line">                &#125;</span><br><span class="line">//写入方法个数</span><br><span class="line">                var14.writeShort(this.methods.size());</span><br><span class="line">                var15 = this.methods.iterator();</span><br><span class="line">//写入方法描述，方法的code属性，以及构造方法和类构造方法</span><br><span class="line">                while(var15.hasNext()) &#123;</span><br><span class="line">                    ProxyGenerator.MethodInfo var21 = (ProxyGenerator.MethodInfo)var15.next();</span><br><span class="line">                    var21.write(var14);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                var14.writeShort(0);</span><br><span class="line">                return var13.toByteArray();</span><br><span class="line">            &#125; catch (IOException var9) &#123;</span><br><span class="line">                throw new InternalError(&quot;unexpected I/O Exception&quot;, var9);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>使用反编译工具查看生产的字节码文件代码,说明了下文件中生成的部分与刚才分析的时候写入的过程的对应关系。：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">package com.sun.proxy;</span><br><span class="line"></span><br><span class="line">import IHello;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line">//生产的代理类都是以$Proxy+唯一的数字为类名的，继承Proxy类同时implements你主题接口</span><br><span class="line">public final class $Proxy0 extends Proxy</span><br><span class="line">  implements IHello</span><br><span class="line">&#123;</span><br><span class="line">  private static Method m1;</span><br><span class="line">  private static Method m3;</span><br><span class="line">  private static Method m2;</span><br><span class="line">  private static Method m0;</span><br><span class="line"></span><br><span class="line">//将InvocationHandler实例放在构造方法里</span><br><span class="line">  public $Proxy0(InvocationHandler paramInvocationHandler)</span><br><span class="line">    throws </span><br><span class="line">  &#123;</span><br><span class="line">    super(paramInvocationHandler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">//重写Object的equals方法</span><br><span class="line">  public final boolean equals(Object paramObject)</span><br><span class="line">    throws </span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      return ((Boolean)this.h.invoke(this, m1, new Object[] &#123; paramObject &#125;)).booleanValue();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (RuntimeException localRuntimeException)</span><br><span class="line">    &#123;</span><br><span class="line">      throw localRuntimeException;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  public final void sayHello()</span><br><span class="line">    throws </span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      this.h.invoke(this, m3, null);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (RuntimeException localRuntimeException)</span><br><span class="line">    &#123;</span><br><span class="line">      throw localRuntimeException;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public final String toString()</span><br><span class="line">    throws </span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      return (String)this.h.invoke(this, m2, null);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (RuntimeException localRuntimeException)</span><br><span class="line">    &#123;</span><br><span class="line">      throw localRuntimeException;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public final int hashCode()</span><br><span class="line">    throws </span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      return ((Integer)this.h.invoke(this, m0, null)).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (RuntimeException localRuntimeException)</span><br><span class="line">    &#123;</span><br><span class="line">      throw localRuntimeException;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static</span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">    //每一个属性所代表的Method都是与上面加入代理方法列表时与固定类绑定的，这是class文件中的格式，方法要与固定的类绑定 </span><br><span class="line">      m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[] &#123; Class.forName(&quot;java.lang.Object&quot;) &#125;);</span><br><span class="line">      m3 = Class.forName(&quot;IHello&quot;).getMethod(&quot;sayHello&quot;, new Class[0]);</span><br><span class="line">      m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]);</span><br><span class="line">      m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (NoSuchMethodException localNoSuchMethodException)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new NoSuchMethodError(localNoSuchMethodException.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    catch (ClassNotFoundException localClassNotFoundException)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    throw new NoClassDefFoundError(localClassNotFoundException.getMessage());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;title-JDK动态代理源码学习&quot;&gt;&lt;a href=&quot;#title-JDK动态代理源码学习&quot; class=&quot;headerlink&quot; title=&quot;title: JDK动态代理源码学习&quot;&gt;&lt;/a&gt;title: JDK动态代理源码学习&lt;/h2&gt;&lt;p&gt;继上一篇博客设计模式之代理模式学习之后&lt;a href=&quot;http://blog.csdn.net/u014427391/article/details/75115928，本博客介绍JDK动态代理的实现原理，学习一下JDK动态代理的源码。&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.csdn.net/u014427391/article/details/75115928，本博客介绍JDK动态代理的实现原理，学习一下JDK动态代理的源码。&lt;/a&gt;&lt;br&gt;Proxy类。该类即为动态代理类，可以使用反编译工具查看jdk里源码。JDK动态代理实现主要由Proxy类的newProxyInstance()方法实现。实现起来很容易，但是学习都要学习原理，所以本博客主要介绍jdk动态代理实现的源码。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;newProxyInstance()方法用于根据传入的接口类型interfaces返回一个动态创建的代理类的实例，方法中第一个参数loader表示代理类的类加载器，第二个参数interfaces表示被代理类实现的接口列表，第三个参数h表示所指派的调用处理程序类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先写个例子实现jdk动态代理&lt;br&gt;主题接口类：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public interface IHello &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public void sayHello();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;+
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.ittrading.cn/2018/01/16/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6RocketMQ%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B%E2%91%A0/"/>
    <id>http://blog.ittrading.cn/2018/01/16/分布式消息中间件RocketMQ学习教程①/</id>
    <published>2018-01-16T09:27:55.431Z</published>
    <updated>2018-01-16T10:01:29.026Z</updated>
    
    <content type="html"><![CDATA[<h2 id="title-分布式消息中间件RocketMQ学习教程①"><a href="#title-分布式消息中间件RocketMQ学习教程①" class="headerlink" title="title: 分布式消息中间件RocketMQ学习教程①"></a>title: 分布式消息中间件RocketMQ学习教程①</h2><p>[TOC]</p><h1 id="消息中间件简介"><a href="#消息中间件简介" class="headerlink" title="消息中间件简介"></a>消息中间件简介</h1><p>消息队列(Message Queue，简称MQ)。消息中间件作为实现分布式消息系统可拓展、可伸缩性的关键组件，具有高吞吐量、高可用等等优点。</p><h1 id="常用消息队列对比"><a href="#常用消息队列对比" class="headerlink" title="常用消息队列对比"></a>常用消息队列对比</h1><p>常用的消息队列有RocketMQ、kafka、ActiveMQ、RabbitMQ、ZeroMQ等等<br>activemq rabbitmq 与 kafka、rocketmq有很大的区别就是前2个只支持主从模式，后2个是分布式消息系统，支持分布式。<br>持久化消息比较： zeroMq不支持，activeMq和rabbitMq都支持。</p><p><excerpt in="" index="" |="" 首页摘要=""><br>+<a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><h2 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h2><p>RocketMQ 是一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。</p><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><p>Kafka是没有重发机制的消息队列。它以可水平扩展和高吞吐率而被广泛使用。目前越来越多的开源分布式处理系统如Cloudera、Apache Storm、Spark都支持与Kafka集成。kafka不完全符合jms规范，注重吞吐量，类似udp 和 tcp。kafka吞吐量大 ，对数据不是百分之百保证的，会有数据丢失，不是百分百送达。所以kafka适合大数据量流转， 比如日志数据 比如用作统计的数据</p><h2 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h2><p>ActiveMQ类似于ZemoMQ，它可以部署于代理模式和P2P模式。类似于RabbitMQ，它易于实现高级场景，而且只需付出低消耗。</p><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p>RabbitMQ是AMQP协议领先的一个实现，它实现了代理(Broker)架构，意味着消息在发送到客户端之前可以在中央节点上排队。此特性使得RabbitMQ易于使用和部署，适宜于很多场景如路由、负载均衡或消息持久化等，用消息队列只需几行代码即可搞定。但是，这使得它的可扩展性差，速度较慢，因为中央节点增加了延迟，消息封装后也比较大。</p><h2 id="ZeroMQ"><a href="#ZeroMQ" class="headerlink" title="ZeroMQ"></a>ZeroMQ</h2><p>ZeroMQ是一个非常轻量级的消息系统，专门为高吞吐量/低延迟的场景开发，在金融界的应用中经常可以发现它。</p><h1 id="RocketMQ简介"><a href="#RocketMQ简介" class="headerlink" title="RocketMQ简介"></a>RocketMQ简介</h1><p>RocketMQ 是一款分布式、队列模型的消息中间件。RocketMQ是由Metaq发展而来，Metaq3.0的时候，改名RocketMQ。<br>RocketMQ 是一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。</p><p>##RocketMQ主要组成：<br>RocketMQ主要组成：NameServer、Broker（代理）、Producer（消<br>息生产者）、Cosumer（消息消费者）</p><h3 id="NameServer"><a href="#NameServer" class="headerlink" title="NameServer"></a>NameServer</h3><p>NameServer：  rocketmq名称服务器，大致相当于 jndi技术，更新和发现 broker服务。一个几乎无状态节点，可集群部署，节点之间无任何信息同步</p><h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><p>Producer：  消息生产者。</p><blockquote><p>Producer与Name Server其中一个节点建立连接。定期从Name Server取Topic信息。并与提供该Topic信息的Master建立长连接。Producer也可以集群部署。</p></blockquote><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>Consumer： 消息消费者。</p><blockquote><p>Consumer 与Name Server 集群中的其中一个节点（随机选择）建立长连接，定期从Name Server 取Topic 路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳。Consumer既可以从Master订阅消息，也可以从Slave订阅消息，订阅规则由Broker配置决定。</p></blockquote><h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h3><p>Broker：消息中转角色，负责存储和转发消息。Broker分为Master和Slave。</p><blockquote><p>一个Master可以对应多个Slave，但是一个Slave只能对应一个Master。Master和Slave的对应关系通过指定相同的BrokerName，不同的BrokerId来定义。BrokerId为0表示Master，BrokerId非0表示Slave。然后所有的Broker和Name Server上的节点建立长连接,定时注册Topic信息到所有Name Server。</p></blockquote><p>Broker-Master：broker 消息主机服务器</p><p>Broker-Slave：  broker 消息从机服务器</p><p><img src="http://img.blog.csdn.net/20171106110449702?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDQyNzM5MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h1 id="RocketMQ存储特点"><a href="#RocketMQ存储特点" class="headerlink" title="RocketMQ存储特点"></a>RocketMQ存储特点</h1><p>Consumer消费消息过程，使用了零拷贝，零拷贝包含以下两种方式：</p><ol><li>使用mmap + write方式</li></ol><p>优点：即使频繁调用，使用小块文件传输，效率也很高 </p><p>缺点：不能很好的利用DMA方式，会比sendfile多消耗CPU，内存安全性控制复杂，需要避免JVM Crash问题。</p><ol><li>使用sendfile方式 </li></ol><p>优点：可以利用DMA方式，消耗CPU较少，大块文件传输效率高，无内存安全新问题。 </p><p>缺点：小块文件效率低于mmap方式，只能是BIO方式传输，不能使用NIO。</p><p>RocketMQ选择了第一种方式，mmap+write方式，因为有小块数据传输的需求，效果会比sendfile更好。</p><h1 id="RocketMQ集群配置"><a href="#RocketMQ集群配置" class="headerlink" title="RocketMQ集群配置"></a>RocketMQ集群配置</h1><p>RocketMQ集群配置<br><img src="http://img.blog.csdn.net/20171025170915316?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDQyNzM5MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h1 id="附录：安装教程"><a href="#附录：安装教程" class="headerlink" title="附录：安装教程"></a>附录：安装教程</h1><p><a href="http://www.linuxidc.com/Linux/2016-09/134941.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2016-09/134941.htm</a></p><p>##【JDK安装】<br>因为RocketMQ是基于Java开发的，所以安装RocketMQ之前，我们需要先安装JDK，因为服务器一般采用Linux，所以本博客只介绍基于Linux系统的教程</p><p>###1.在/usr/目录下创建java目录<br>mkdir /usr/java </p><p>###进入java目录<br>cd /usr/java</p><p>###2.下载jdk到/usr/java目录，然后tar解压(可以使用xftp在本地下载jdk，或者使用命令curl -O url下载)<br>tar -zxvf jdk-8u102-linux-x64.tar.gz</p><p>###3.设置环境变量</p><p>###vi编辑<br>vi /etc/profile </p><p>###profile文件加入如下配置，如何按esc退出，:wq!保持<br>export JAVA_HOME=/usr/java/jdk1.8.0_102<br>export PATH=$PATH:$JAVA_HOME/bin<br>export CLASSPATH=.:$JAVA_HOME/lib</p><p>###让修改生效<br>source /etc/profile</p><p>###验证jdk有效性<br>java -version<br>假如系统有安装yum，就可以直接使用yum install java-1.7.0-openjdk下载jdk</p><p>###设置环境变量，其它操作同上<br>export JAVA_HOME=/usr/java/jdk1.8.0_102<br>export PATH=$PATH:$JAVA_HOME/bin<br>export CLASSPATH=.:$JAVA_HOME/lib</p><p>##【RocketMQ安装】<br><a href="http://www.linuxidc.com/Linux/2015-10/124112.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2015-10/124112.htm</a></p><p>###解压并复制到/usr/local目录<br>tar zxf alibaba-rocketmq-3.2.2.tar.gz -C /usr/local/</p><p>###进入/usr/local目录<br>cd /usr/local/</p><p>###建立一个同步的链接,使用ln命令<br>ln -s /usr/local/alibaba-rocketmq /usr/local/rocketmq</p><p>###进入同步的文件夹<br>cd rocketmq/</p><p>###vim编辑配置文件<br>vim conf/2m-noslave/broker-a.properties<br>参考配置文件<br>brokerClusterName=FusionCluster<br>brokerName=broker-a<br>brokerId=0<br>namesrvAddr=dbTest249:9876;webTest251:9876<br>deleteWhen=04<br>fileReservedTime=120<br>brokerRole=ASYNC_MASTER<br>flushDiskType=ASYNC_FLUSH<br>sstorePathRootDir=/data/rocketmq/store<br>storePathCommitLog=/data/rocketmq/store/commitlog</p><p>###编辑JAVA内存块<br>vim bin/runbroker.sh<br>JAVA_OPT_1=”-server -Xms512m -Xmx1g -XX:PermSize=128m -XX:MaxPermSize=320m”</p><p>###创建数据目录<br>mkdir -p /data/rocketmq/store/commitlog<br>mkdir /data/logs<br>cd conf/<br>sed -i ‘s#${user.home}#/data#g’ *.xml　　　　　　<br>//将conf目录下所有xml文件中的${user.home}替换成/data,进入rocketmq/conf目录下执行该命令</p><p>###启动RocketMQ<br>cd ../bin/<br>nohup sh mqnamesrv &gt;/var/log/ns.log 2&gt;&amp;1 &amp;<br>nohup sh mqbroker -c ../conf/2m-noslave/broker-a.properties &gt; /var/log/mq.log 2&gt;&amp;1 &amp;</p><p>###查看启动日志<br>tail -f /var/log/ns.log<br>tail -f /var/log/mq.log</p><p>###查看启动端口<br>netstat -tunpl<br>jps</p><p>###关闭RocketMQ<br>sh mqshutdown<br>sh mqshutdown broker<br>sh mqshutdown namesrv</p><p>###再次启动<br>nohup sh mqnamesrv &gt;/var/log/ns.log 2&gt;&amp;1 &amp;<br>nohup sh mqbroker -c ../conf/2m-noslave/broker-a.properties &gt; /var/log/mq.log 2&gt;&amp;1 &amp;</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;title-分布式消息中间件RocketMQ学习教程①&quot;&gt;&lt;a href=&quot;#title-分布式消息中间件RocketMQ学习教程①&quot; class=&quot;headerlink&quot; title=&quot;title: 分布式消息中间件RocketMQ学习教程①&quot;&gt;&lt;/a&gt;title: 分布式消息中间件RocketMQ学习教程①&lt;/h2&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;消息中间件简介&quot;&gt;&lt;a href=&quot;#消息中间件简介&quot; class=&quot;headerlink&quot; title=&quot;消息中间件简介&quot;&gt;&lt;/a&gt;消息中间件简介&lt;/h1&gt;&lt;p&gt;消息队列(Message Queue，简称MQ)。消息中间件作为实现分布式消息系统可拓展、可伸缩性的关键组件，具有高吞吐量、高可用等等优点。&lt;/p&gt;
&lt;h1 id=&quot;常用消息队列对比&quot;&gt;&lt;a href=&quot;#常用消息队列对比&quot; class=&quot;headerlink&quot; title=&quot;常用消息队列对比&quot;&gt;&lt;/a&gt;常用消息队列对比&lt;/h1&gt;&lt;p&gt;常用的消息队列有RocketMQ、kafka、ActiveMQ、RabbitMQ、ZeroMQ等等&lt;br&gt;activemq rabbitmq 与 kafka、rocketmq有很大的区别就是前2个只支持主从模式，后2个是分布式消息系统，支持分布式。&lt;br&gt;持久化消息比较： zeroMq不支持，activeMq和rabbitMq都支持。&lt;/p&gt;
&lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;+
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.ittrading.cn/2018/01/16/SpringBoot%E9%9B%86%E6%88%90Redis%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98%E5%A4%84%E7%90%86(Spring%20AOP%E6%8A%80%E6%9C%AF)/"/>
    <id>http://blog.ittrading.cn/2018/01/16/SpringBoot集成Redis实现缓存处理(Spring AOP技术)/</id>
    <published>2018-01-16T07:27:25.781Z</published>
    <updated>2018-01-16T10:02:48.217Z</updated>
    
    <content type="html"><![CDATA[<h2 id="title-SpringBoot集成Redis实现缓存处理"><a href="#title-SpringBoot集成Redis实现缓存处理" class="headerlink" title="title: SpringBoot集成Redis实现缓存处理"></a>title: SpringBoot集成Redis实现缓存处理</h2><h3 id="第一章-需求分析"><a href="#第一章-需求分析" class="headerlink" title="第一章 需求分析"></a>第一章 需求分析</h3><p>计划在Team的开源项目里加入Redis实现缓存处理，因为业务功能已经实现了一部分，通过写Redis工具类，然后引用，改动量较大，而且不可以实现解耦合，所以想到了Spring框架的AOP(面向切面编程)。<br>开源项目：<a href="https://github.com/u014427391/jeeplatform" target="_blank" rel="noopener">https://github.com/u014427391/jeeplatform</a><br>欢迎star(收藏)</p><h3 id="第二章-SpringBoot简介"><a href="#第二章-SpringBoot简介" class="headerlink" title="第二章 SpringBoot简介"></a>第二章 SpringBoot简介</h3><blockquote><p>Spring框架作为JavaEE框架领域的一款重要的开源框架，在企业应用开发中有着很重要的作用，同时Spring框架及其子框架很多，所以知识量很广。<br>SpringBoot：一款Spring框架的子框架，也可以叫微框架，是2014年推出的一款使Spring框架开发变得容易的框架。学过Spring框架的都知识，Spring框架难以避免地需要配置不少XMl，而使用SpringBoot框架的话，就可以使用注解开发，极大地简化基于Spring框架的开发。SpringBoot充分利用了JavaConfig的配置模式以及“约定优于配置”的理念，能够极大的简化基于SpringMVC的Web应用和REST服务开发。</p></blockquote><p><excerpt in="" index="" |="" 首页摘要=""><br>+<a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><h3 id="第三章-Redis简介"><a href="#第三章-Redis简介" class="headerlink" title="第三章 Redis简介"></a>第三章 Redis简介</h3><p>####3.1 Redis安装部署(Linux)<br>Redis安装部署的可以参考我的博客(Redis是基于C编写的，所以安装前先安装gcc编译器)：<a href="http://blog.csdn.net/u014427391/article/details/71210989" target="_blank" rel="noopener">http://blog.csdn.net/u014427391/article/details/71210989</a></p><h4 id="3-2-Redis简介"><a href="#3-2-Redis简介" class="headerlink" title="3.2 Redis简介"></a>3.2 Redis简介</h4><blockquote><p>Redis如今已经成为Web开发社区最火热的内存数据库之一，随着Web2.0的快速发展，再加上半结构数据比重加大，网站对高效性能的需求也越来越多。<br>而且大型网站一般都有几百台或者更多Redis服务器。Redis作为一款功能强大的系统，无论是存储、队列还是缓存系统，都有其用武之地。</p></blockquote><p>SpringBoot框架入门的可以参考我之前的博客：<a href="http://blog.csdn.net/u014427391/article/details/70655332" target="_blank" rel="noopener">http://blog.csdn.net/u014427391/article/details/70655332</a></p><p>###第四章 Redis缓存实现</p><h4 id="4-1下面结构图"><a href="#4-1下面结构图" class="headerlink" title="4.1下面结构图"></a>4.1下面结构图</h4><p>项目结构图：<br><img src="http://img.blog.csdn.net/20171214104855753?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDQyNzM5MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h4 id="4-2-SpringBoot的yml文件配置"><a href="#4-2-SpringBoot的yml文件配置" class="headerlink" title="4.2 SpringBoot的yml文件配置"></a>4.2 SpringBoot的yml文件配置</h4><p>添加resource下面的application.yml配置，这里主要配置mysql，druid，redis</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line"></span><br><span class="line">    # 主数据源</span><br><span class="line">    shop:</span><br><span class="line">      url: jdbc:mysql://127.0.0.1:3306/jeeplatform?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=utf8&amp;characterSetResults=utf8&amp;useSSL=false</span><br><span class="line">      username: root</span><br><span class="line">      password: root</span><br><span class="line"></span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line"></span><br><span class="line">    # 连接池设置</span><br><span class="line">    druid:</span><br><span class="line">      initial-size: 5</span><br><span class="line">      min-idle: 5</span><br><span class="line">      max-active: 20</span><br><span class="line">      # 配置获取连接等待超时的时间</span><br><span class="line">      max-wait: 60000</span><br><span class="line">      # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒</span><br><span class="line">      time-between-eviction-runs-millis: 60000</span><br><span class="line">      # 配置一个连接在池中最小生存的时间，单位是毫秒</span><br><span class="line">      min-evictable-idle-time-millis: 300000</span><br><span class="line">      # Oracle请使用select 1 from dual</span><br><span class="line">      validation-query: SELECT &apos;x&apos;</span><br><span class="line">      test-while-idle: true</span><br><span class="line">      test-on-borrow: false</span><br><span class="line">      test-on-return: false</span><br><span class="line">      # 打开PSCache，并且指定每个连接上PSCache的大小</span><br><span class="line">      pool-prepared-statements: true</span><br><span class="line">      max-pool-prepared-statement-per-connection-size: 20</span><br><span class="line">      # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，&apos;wall&apos;用于防火墙</span><br><span class="line">      filters: stat,wall,slf4j</span><br><span class="line">      # 通过connectProperties属性来打开mergeSql功能；慢SQL记录</span><br><span class="line">      connection-properties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000</span><br><span class="line">      # 合并多个DruidDataSource的监控数据</span><br><span class="line">      use-global-data-source-stat: true</span><br><span class="line">  jpa:</span><br><span class="line">    database: mysql</span><br><span class="line">    hibernate:</span><br><span class="line">      show_sql: true</span><br><span class="line">      format_sql: true</span><br><span class="line">      ddl-auto: none</span><br><span class="line">      naming:</span><br><span class="line">        physical-strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl</span><br><span class="line">  mvc:</span><br><span class="line">    view:</span><br><span class="line">      prefix: /WEB-INF/jsp/</span><br><span class="line">      suffix: .jsp</span><br><span class="line">  #Jedis配置</span><br><span class="line">  jedis :</span><br><span class="line">    pool :</span><br><span class="line">      host : 127.0.0.1</span><br><span class="line">      port : 6379</span><br><span class="line">      password : password</span><br><span class="line">      timeout : 0</span><br><span class="line">      config :</span><br><span class="line">        maxTotal : 100</span><br><span class="line">        maxIdle : 10</span><br><span class="line">        maxWaitMillis : 100000</span><br></pre></td></tr></table></figure><p>编写一个配置类启动配置JedisConfig.java:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package org.muses.jeeplatform.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;</span><br><span class="line">import org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import redis.clients.jedis.JedisPool;</span><br><span class="line">import redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">//@ConfigurationProperties(prefix = JedisConfig.JEDIS_PREFIX )</span><br><span class="line">public class JedisConfig &#123;</span><br><span class="line"></span><br><span class="line">    //public static final String JEDIS_PREFIX = &quot;jedis&quot;;</span><br><span class="line"></span><br><span class="line">    @Bean(name= &quot;jedisPool&quot;)</span><br><span class="line">    @Autowired</span><br><span class="line">    public JedisPool jedisPool(@Qualifier(&quot;jedisPoolConfig&quot;) JedisPoolConfig config,</span><br><span class="line">                                   @Value(&quot;$&#123;spring.jedis.pool.host&#125;&quot;)String host,</span><br><span class="line">                                   @Value(&quot;$&#123;spring.jedis.pool.port&#125;&quot;)int port,</span><br><span class="line">                                   @Value(&quot;$&#123;spring.jedis.pool.timeout&#125;&quot;)int timeout,</span><br><span class="line">                                   @Value(&quot;$&#123;spring.jedis.pool.password&#125;&quot;)String password) &#123;</span><br><span class="line">            return new JedisPool(config, host, port,timeout,password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name= &quot;jedisPoolConfig&quot;)</span><br><span class="line">    public JedisPoolConfig jedisPoolConfig (@Value(&quot;$&#123;spring.jedis.pool.config.maxTotal&#125;&quot;)int maxTotal,</span><br><span class="line">                                                @Value(&quot;$&#123;spring.jedis.pool.config.maxIdle&#125;&quot;)int maxIdle,</span><br><span class="line">                                                @Value(&quot;$&#123;spring.jedis.pool.config.maxWaitMillis&#125;&quot;)int maxWaitMillis) &#123;</span><br><span class="line">            JedisPoolConfig config = new JedisPoolConfig();</span><br><span class="line">            config.setMaxTotal(maxTotal);</span><br><span class="line">            config.setMaxIdle(maxIdle);</span><br><span class="line">            config.setMaxWaitMillis(maxWaitMillis);</span><br><span class="line">            return config;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####4.3 元注解类编写<br>编写一个元注解类RedisCache.java，被改注解定义的类都自动实现AOP缓存处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package org.muses.jeeplatform.annotation;</span><br><span class="line"></span><br><span class="line">import org.muses.jeeplatform.common.RedisCacheNamespace;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 元注解 用来标识查询数据库的方法</span><br><span class="line"> */</span><br><span class="line">@Documented</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface RedisCache &#123;</span><br><span class="line">//    RedisCacheNamespace nameSpace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>JDK 5提供的注解，除了Retention以外，还有另外三个，即Target 、Inherited 和 Documented。基于这个，我们可以实现自定义的元注解<br>我们设置RedisCache基于Method方法级别引用。</p><blockquote><p>1.RetentionPolicy.SOURCE    这种类型的Annotations只在源代码级别保留,编译时就会被忽略<br>2.RetentionPolicy.CLASS    这种类型的Annotations编译时被保留,在class文件中存在,但JVM将会忽略<br>3.RetentionPolicy.RUNTIME    这种类型的Annotations将被JVM保留,所以他们能在运行时被JVM或其他使用反射机制的代码所读取和使用.</p></blockquote><h4 id="4-4-调用JedisPool实现Redis缓存处理"><a href="#4-4-调用JedisPool实现Redis缓存处理" class="headerlink" title="4.4 调用JedisPool实现Redis缓存处理"></a>4.4 调用JedisPool实现Redis缓存处理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package org.muses.jeeplatform.cache;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import redis.clients.jedis.Jedis;</span><br><span class="line">import redis.clients.jedis.JedisPool;</span><br><span class="line"></span><br><span class="line">import javax.annotation.Resource;</span><br><span class="line">@Component(&quot;redisCache&quot;)</span><br><span class="line">public class RedisCache &#123;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">private JedisPool getJedisPool()&#123;</span><br><span class="line">return jedisPool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setJedisPool(JedisPool jedisPool)&#123;</span><br><span class="line">this.jedisPool = jedisPool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 从Redis缓存获取数据</span><br><span class="line"> * @param redisKey</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public Object getDataFromRedis(String redisKey)&#123;</span><br><span class="line">Jedis jedis = jedisPool.getResource();</span><br><span class="line">byte[] byteArray = jedis.get(redisKey.getBytes());</span><br><span class="line"></span><br><span class="line">if(byteArray != null)&#123;</span><br><span class="line">return SerializeUtil.unSerialize(byteArray);</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 保存数据到Redis</span><br><span class="line"> * @param redisKey</span><br><span class="line"> */</span><br><span class="line">public String saveDataToRedis(String redisKey,Object obj)&#123;</span><br><span class="line"></span><br><span class="line">byte[] bytes = SerializeUtil.serialize(obj);</span><br><span class="line"></span><br><span class="line">Jedis jedis = jedisPool.getResource();</span><br><span class="line"></span><br><span class="line">String code = jedis.set(redisKey.getBytes(), bytes);</span><br><span class="line"></span><br><span class="line">return code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象序列化的工具类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">package org.muses.jeeplatform.cache;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class SerializeUtil &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 序列化对象</span><br><span class="line"> * @param obj</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static byte[] serialize(Object obj)&#123;</span><br><span class="line">ObjectOutputStream oos = null;</span><br><span class="line">ByteArrayOutputStream baos = null;</span><br><span class="line">try&#123;</span><br><span class="line">baos = new ByteArrayOutputStream();</span><br><span class="line">oos = new ObjectOutputStream(baos);</span><br><span class="line"></span><br><span class="line">oos.writeObject(obj);</span><br><span class="line">byte[] byteArray = baos.toByteArray();</span><br><span class="line">return byteArray;</span><br><span class="line"></span><br><span class="line">&#125;catch(IOException e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 反序列化对象</span><br><span class="line"> * @param byteArray</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static Object unSerialize(byte[] byteArray)&#123;</span><br><span class="line">ByteArrayInputStream bais = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            //反序列化为对象</span><br><span class="line">            bais = new ByteArrayInputStream(byteArray);</span><br><span class="line">            ObjectInputStream ois = new ObjectInputStream(bais);</span><br><span class="line">            return ois.readObject();</span><br><span class="line">            </span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里记得Vo类都要实现Serializable<br>例如菜单信息VO类，这是一个JPA映射的实体类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line">package org.muses.jeeplatform.core.entity.admin;</span><br><span class="line"></span><br><span class="line">import javax.persistence.*;</span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @description 菜单信息实体</span><br><span class="line"> * @author Nicky</span><br><span class="line"> * @date 2017年3月17日</span><br><span class="line"> */</span><br><span class="line">@Table(name=&quot;sys_menu&quot;)</span><br><span class="line">@Entity</span><br><span class="line">public class Menu implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">/** 菜单Id**/</span><br><span class="line">private int menuId;</span><br><span class="line"></span><br><span class="line">/** 上级Id**/</span><br><span class="line">private int parentId;</span><br><span class="line"></span><br><span class="line">/** 菜单名称**/</span><br><span class="line">private String menuName;</span><br><span class="line"></span><br><span class="line">/** 菜单图标**/</span><br><span class="line">private String menuIcon;</span><br><span class="line"></span><br><span class="line">/** 菜单URL**/</span><br><span class="line">private String menuUrl;</span><br><span class="line"></span><br><span class="line">/** 菜单类型**/</span><br><span class="line">private String menuType;</span><br><span class="line"></span><br><span class="line">/** 菜单排序**/</span><br><span class="line">private String menuOrder;</span><br><span class="line"></span><br><span class="line">/**菜单状态**/</span><br><span class="line">private String menuStatus;</span><br><span class="line"></span><br><span class="line">private List&lt;Menu&gt; subMenu;</span><br><span class="line"></span><br><span class="line">private String target;</span><br><span class="line"></span><br><span class="line">private boolean hasSubMenu = false;</span><br><span class="line"></span><br><span class="line">public Menu() &#123;</span><br><span class="line">super();</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">@Id</span><br><span class="line">@GeneratedValue(strategy=GenerationType.IDENTITY)</span><br><span class="line">public int getMenuId() &#123;</span><br><span class="line">return this.menuId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setMenuId(int menuId) &#123;</span><br><span class="line">this.menuId = menuId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Column(length=100)</span><br><span class="line">public int getParentId() &#123;</span><br><span class="line">return parentId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setParentId(int parentId) &#123;</span><br><span class="line">this.parentId = parentId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Column(length=100)</span><br><span class="line">public String getMenuName() &#123;</span><br><span class="line">return this.menuName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setMenuName(String menuName) &#123;</span><br><span class="line">this.menuName = menuName;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">@Column(length=30)</span><br><span class="line">public String getMenuIcon() &#123;</span><br><span class="line">return this.menuIcon;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setMenuIcon(String menuIcon) &#123;</span><br><span class="line">this.menuIcon = menuIcon;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">@Column(length=100)</span><br><span class="line">public String getMenuUrl() &#123;</span><br><span class="line">return this.menuUrl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setMenuUrl(String menuUrl) &#123;</span><br><span class="line">this.menuUrl = menuUrl;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">@Column(length=100)</span><br><span class="line">public String getMenuType() &#123;</span><br><span class="line">return this.menuType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setMenuType(String menuType) &#123;</span><br><span class="line">this.menuType = menuType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Column(length=10)</span><br><span class="line">public String getMenuOrder() &#123;</span><br><span class="line">return menuOrder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setMenuOrder(String menuOrder) &#123;</span><br><span class="line">this.menuOrder = menuOrder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Column(length=10)</span><br><span class="line">public String getMenuStatus()&#123;</span><br><span class="line">return menuStatus;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setMenuStatus(String menuStatus)&#123;</span><br><span class="line">this.menuStatus = menuStatus;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Transient</span><br><span class="line">public List&lt;Menu&gt; getSubMenu() &#123;</span><br><span class="line">return subMenu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setSubMenu(List&lt;Menu&gt; subMenu) &#123;</span><br><span class="line">this.subMenu = subMenu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setTarget(String target)&#123;</span><br><span class="line">this.target = target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Transient</span><br><span class="line">public String getTarget()&#123;</span><br><span class="line">return target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setHasSubMenu(boolean hasSubMenu)&#123;</span><br><span class="line">this.hasSubMenu = hasSubMenu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Transient</span><br><span class="line">public boolean getHasSubMenu()&#123;</span><br><span class="line">return hasSubMenu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####4.5 Spring AOP实现监控所有被@RedisCache注解的方法缓存</p><p>先从Redis里获取缓存,查询不到，就查询MySQL数据库，然后再保存到Redis缓存里，下次查询时直接调用Redis缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">package org.muses.jeeplatform.cache;</span><br><span class="line"></span><br><span class="line">import org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line">import org.aspectj.lang.annotation.Around;</span><br><span class="line">import org.aspectj.lang.annotation.Aspect;</span><br><span class="line">import org.aspectj.lang.annotation.Pointcut;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * AOP实现Redis缓存处理</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">@Aspect</span><br><span class="line">public class RedisAspect &#123;</span><br><span class="line"></span><br><span class="line">private static final Logger LOGGER = LoggerFactory.getLogger(RedisAspect.class);</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">    @Qualifier(&quot;redisCache&quot;)</span><br><span class="line">private RedisCache redisCache;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 拦截所有元注解RedisCache注解的方法</span><br><span class="line"> */</span><br><span class="line">@Pointcut(&quot;@annotation(org.muses.jeeplatform.annotation.RedisCache)&quot;)</span><br><span class="line">public void pointcutMethod()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 环绕处理，先从Redis里获取缓存,查询不到，就查询MySQL数据库，</span><br><span class="line"> * 然后再保存到Redis缓存里</span><br><span class="line"> * @param joinPoint</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@Around(&quot;pointcutMethod()&quot;)</span><br><span class="line">public Object around(ProceedingJoinPoint joinPoint)&#123;</span><br><span class="line">//前置：从Redis里获取缓存</span><br><span class="line">//先获取目标方法参数</span><br><span class="line">long startTime = System.currentTimeMillis();</span><br><span class="line">String applId = null;</span><br><span class="line">Object[] args = joinPoint.getArgs();</span><br><span class="line">if (args != null &amp;&amp; args.length &gt; 0) &#123;</span><br><span class="line">applId = String.valueOf(args[0]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//获取目标方法所在类</span><br><span class="line">String target = joinPoint.getTarget().toString();</span><br><span class="line">String className = target.split(&quot;@&quot;)[0];</span><br><span class="line"></span><br><span class="line">//获取目标方法的方法名称</span><br><span class="line">String methodName = joinPoint.getSignature().getName();</span><br><span class="line"></span><br><span class="line">//redis中key格式：    applId:方法名称</span><br><span class="line">String redisKey = applId + &quot;:&quot; + className + &quot;.&quot; + methodName;</span><br><span class="line"></span><br><span class="line">Object obj = redisCache.getDataFromRedis(redisKey);</span><br><span class="line"></span><br><span class="line">if(obj!=null)&#123;</span><br><span class="line">LOGGER.info(&quot;**********从Redis中查到了数据**********&quot;);</span><br><span class="line">LOGGER.info(&quot;Redis的KEY值:&quot;+redisKey);</span><br><span class="line">LOGGER.info(&quot;REDIS的VALUE值:&quot;+obj.toString());</span><br><span class="line">return obj;</span><br><span class="line">&#125;</span><br><span class="line">long endTime = System.currentTimeMillis();</span><br><span class="line">LOGGER.info(&quot;Redis缓存AOP处理所用时间:&quot;+(endTime-startTime));</span><br><span class="line">LOGGER.info(&quot;**********没有从Redis查到数据**********&quot;);</span><br><span class="line">try&#123;</span><br><span class="line">obj = joinPoint.proceed();</span><br><span class="line">&#125;catch(Throwable e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">LOGGER.info(&quot;**********开始从MySQL查询数据**********&quot;);</span><br><span class="line">//后置：将数据库查到的数据保存到Redis</span><br><span class="line">String code = redisCache.saveDataToRedis(redisKey,obj);</span><br><span class="line">if(code.equals(&quot;OK&quot;))&#123;</span><br><span class="line">LOGGER.info(&quot;**********数据成功保存到Redis缓存!!!**********&quot;);</span><br><span class="line">LOGGER.info(&quot;Redis的KEY值:&quot;+redisKey);</span><br><span class="line">LOGGER.info(&quot;REDIS的VALUE值:&quot;+obj.toString());</span><br><span class="line">&#125;</span><br><span class="line">return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后调用@RedisCache实现缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 通过菜单Id获取菜单信息</span><br><span class="line"> * @param id</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@Transactional</span><br><span class="line">@RedisCache</span><br><span class="line">public Menu findMenuById(@RedisCacheKey int id)&#123;</span><br><span class="line">return menuRepository.findMenuByMenuId(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>登录系统，然后加入@RedisCache注解的方法都会实现Redis缓存处理<br><img src="http://img.blog.csdn.net/20171214112834478?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDQyNzM5MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><img src="http://img.blog.csdn.net/20171214104250995?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDQyNzM5MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>可以看到Redis里保存到了缓存</p><p><img src="http://img.blog.csdn.net/20171214104303308?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDQyNzM5MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>项目代码：<a href="https://github.com/u014427391/jeeplatform,欢迎去github上star(收藏" target="_blank" rel="noopener">https://github.com/u014427391/jeeplatform,欢迎去github上star(收藏</a>)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;title-SpringBoot集成Redis实现缓存处理&quot;&gt;&lt;a href=&quot;#title-SpringBoot集成Redis实现缓存处理&quot; class=&quot;headerlink&quot; title=&quot;title: SpringBoot集成Redis实现缓存处理&quot;&gt;&lt;/a&gt;title: SpringBoot集成Redis实现缓存处理&lt;/h2&gt;&lt;h3 id=&quot;第一章-需求分析&quot;&gt;&lt;a href=&quot;#第一章-需求分析&quot; class=&quot;headerlink&quot; title=&quot;第一章 需求分析&quot;&gt;&lt;/a&gt;第一章 需求分析&lt;/h3&gt;&lt;p&gt;计划在Team的开源项目里加入Redis实现缓存处理，因为业务功能已经实现了一部分，通过写Redis工具类，然后引用，改动量较大，而且不可以实现解耦合，所以想到了Spring框架的AOP(面向切面编程)。&lt;br&gt;开源项目：&lt;a href=&quot;https://github.com/u014427391/jeeplatform&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/u014427391/jeeplatform&lt;/a&gt;&lt;br&gt;欢迎star(收藏)&lt;/p&gt;
&lt;h3 id=&quot;第二章-SpringBoot简介&quot;&gt;&lt;a href=&quot;#第二章-SpringBoot简介&quot; class=&quot;headerlink&quot; title=&quot;第二章 SpringBoot简介&quot;&gt;&lt;/a&gt;第二章 SpringBoot简介&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Spring框架作为JavaEE框架领域的一款重要的开源框架，在企业应用开发中有着很重要的作用，同时Spring框架及其子框架很多，所以知识量很广。&lt;br&gt;SpringBoot：一款Spring框架的子框架，也可以叫微框架，是2014年推出的一款使Spring框架开发变得容易的框架。学过Spring框架的都知识，Spring框架难以避免地需要配置不少XMl，而使用SpringBoot框架的话，就可以使用注解开发，极大地简化基于Spring框架的开发。SpringBoot充分利用了JavaConfig的配置模式以及“约定优于配置”的理念，能够极大的简化基于SpringMVC的Web应用和REST服务开发。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;+
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.ittrading.cn/2018/01/16/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    <id>http://blog.ittrading.cn/2018/01/16/MySQL数据库的锁机制/</id>
    <published>2018-01-16T07:26:58.605Z</published>
    <updated>2018-01-16T09:43:58.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="title-MySQL数据库的锁机制"><a href="#title-MySQL数据库的锁机制" class="headerlink" title="title:MySQL数据库的锁机制"></a>title:MySQL数据库的锁机制</h2><p>在并发访问情况下，很有可能出现不可重复读等等读现象。为了更好的应对高并发，封锁、时间戳、乐观并发控制(乐观锁)、悲观并发控制(悲观锁)都是并发控制采用的主要技术方式。</p><p>###锁分类<br>①、按操作划分：DML锁，DDL锁<br>②、按锁的粒度划分：表级锁、行级锁、页级锁<br>③、按锁级别划分：共享锁、排他锁<br>④、按加锁方式划分：自动锁、显示锁<br>⑤、按使用方式划分：乐观锁、悲观锁</p><p>###乐观锁和悲观锁</p><p>乐观并发控制和悲观并发控制是并发控制采用的主要方法。乐观锁和悲观锁不仅在关系数据库里应用，在Hibernate、Memcache等等也有相关概念。</p><p>悲观锁：也即悲观并发控制，Pessimistic Concurrency Controller，缩写PCC。悲观锁是指在数据处理过程，使数据处于锁定状态，一般使用数据库的锁机制实现。<br>备注，在MySQL中使用悲观锁，必须关闭MySQL的自动提交，set autocommit=0。MySQL默认使用自动提交autocommit模式，也即你执行一个更新操作，MySQL会自动将结果提交。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//0.开始事务</span><br><span class="line">begin;/begin work;/start transaction; (三者选一就可</span><br><span class="line">//1.查询出商品信息</span><br><span class="line">select status from t_goods where id=1 for update;</span><br><span class="line">//2.根据商品信息生成订单</span><br><span class="line">insert into t_orders (id,goods_id) values (null,1);</span><br><span class="line">//3.修改商品status为2</span><br><span class="line">update t_goods set status=2;</span><br><span class="line">//4.提交事务</span><br><span class="line">commit;/commit work;</span><br></pre></td></tr></table></figure><p>本例子使用select…for update方式将数据锁住，也就是开启了排他锁</p><p><excerpt in="" index="" |="" 首页摘要=""><br>+<a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><blockquote><p>悲观锁优缺点：<br>悲观并发控制(悲观锁)采用”先取锁再分”的保守策略，为数据处理提供了安全的保证。但在效率方面，加锁机制会产生额外的开销，增加产生死锁的机会。</p></blockquote><p>乐观锁：相对悲观锁来说，乐观锁是通过记录数据版本的方式实现乐观锁。为数据增加一个版本标识，读取数据时，将版本标识一起读出，数据没更新一次，就对版本标识进行更新。</p><blockquote><p>乐观锁优缺点：<br>乐观锁认为事务直接竞争的概率是很小的，在提交的时候才锁定，所以不会产生死锁。但是如果两个事务同时读取数据库的某一行，这时，就会发现乐观锁的弊端。</p></blockquote><p>###MySQL常用存储引擎的锁机制</p><blockquote><p>BDB：支持页级锁和表级锁，默认是页级锁<br>InnoDB：支持行级锁和表级锁，默认是行级锁<br>MyISAM &amp;Memory：这两个存储引擎都是采用表级锁</p></blockquote><p>###MySQL中排它锁和共享锁<br>排它锁(exclusive locck)<br>排它锁又叫写锁，如果事务T对A加上排它锁，则其它事务都不能对A加任何类型的锁。获准排它锁的事务既能读数据，又能写数据。</p><blockquote><p>用法：SELECT … FOR UPDATE</p></blockquote><p>共享锁(share lock)<br>共享锁又叫读锁，如果事务T对A加上共享锁，则其它事务只能对A再加共享锁，不能加其它锁。获准共享锁的事务只能读数据，不能写数据。</p><blockquote><p>用法：SELECT … LOCK IN SHARE MODE;</p></blockquote><p>###MySQL中的行级锁、表级锁和页级锁</p><blockquote><p>行级锁：行级锁分为共享锁和排它锁。行级锁是Mysql中锁定粒度最细的锁。InnoDB引擎支持行级锁和表级锁，只有在通过索引条件检索数据的时候，才使用行级锁，否就使用表级锁。行级锁开销大，加锁慢，锁定粒度最小，发生锁冲突概率最低，并发度最高</p><p>表级锁：表级锁分为表共享锁和表独占锁。表级锁开销小，加锁快，锁定粒度大、发生锁冲突最高，并发度最低</p><p>页级锁：页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB支持页级锁。<br>开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</p></blockquote><p><a href="http://www.hollischuang.com/archives/934" target="_blank" rel="noopener">http://www.hollischuang.com/archives/934</a><br><a href="https://crossoverjie.top/2017/07/09/SSM15/" target="_blank" rel="noopener">https://crossoverjie.top/2017/07/09/SSM15/</a></p></the>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;title-MySQL数据库的锁机制&quot;&gt;&lt;a href=&quot;#title-MySQL数据库的锁机制&quot; class=&quot;headerlink&quot; title=&quot;title:MySQL数据库的锁机制&quot;&gt;&lt;/a&gt;title:MySQL数据库的锁机制&lt;/h2&gt;&lt;p&gt;在并发访问情况下，很有可能出现不可重复读等等读现象。为了更好的应对高并发，封锁、时间戳、乐观并发控制(乐观锁)、悲观并发控制(悲观锁)都是并发控制采用的主要技术方式。&lt;/p&gt;
&lt;p&gt;###锁分类&lt;br&gt;①、按操作划分：DML锁，DDL锁&lt;br&gt;②、按锁的粒度划分：表级锁、行级锁、页级锁&lt;br&gt;③、按锁级别划分：共享锁、排他锁&lt;br&gt;④、按加锁方式划分：自动锁、显示锁&lt;br&gt;⑤、按使用方式划分：乐观锁、悲观锁&lt;/p&gt;
&lt;p&gt;###乐观锁和悲观锁&lt;/p&gt;
&lt;p&gt;乐观并发控制和悲观并发控制是并发控制采用的主要方法。乐观锁和悲观锁不仅在关系数据库里应用，在Hibernate、Memcache等等也有相关概念。&lt;/p&gt;
&lt;p&gt;悲观锁：也即悲观并发控制，Pessimistic Concurrency Controller，缩写PCC。悲观锁是指在数据处理过程，使数据处于锁定状态，一般使用数据库的锁机制实现。&lt;br&gt;备注，在MySQL中使用悲观锁，必须关闭MySQL的自动提交，set autocommit=0。MySQL默认使用自动提交autocommit模式，也即你执行一个更新操作，MySQL会自动将结果提交。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//0.开始事务&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;begin;/begin work;/start transaction; (三者选一就可&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//1.查询出商品信息&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;select status from t_goods where id=1 for update;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//2.根据商品信息生成订单&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;insert into t_orders (id,goods_id) values (null,1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//3.修改商品status为2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;update t_goods set status=2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//4.提交事务&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;commit;/commit work;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;本例子使用select…for update方式将数据锁住，也就是开启了排他锁&lt;/p&gt;
&lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;+
    
    </summary>
    
    
  </entry>
  
</feed>
